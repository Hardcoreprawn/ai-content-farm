---
name: Scheduled Content Collection

on:
  schedule:
    # Run every 4 hours at minute 0: 00:00, 04:00, 08:00, 12:00, 16:00, 20:00 UTC
    - cron: '0 */4 * * *'
  workflow_dispatch:  # Allow manual triggering
    inputs:
      template:
        description: 'Collection template to use'
        required: false
        default: 'default.json'
        type: choice
        options:
          - default.json
          - discovery.json
          - tech-rss.json
          - web-overlap-test.json

permissions:
  contents: read
  id-token: write

env:
  AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  COLLECTION_TEMPLATE: ${{ inputs.template || 'default.json' }}

jobs:
  trigger-content-collection:
    name: Trigger Content Collection
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'  # Only run on main branch

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Get Container App URL
        id: get-url
        run: |
          # Get the content collector container app URL
          URL=$(az containerapp show \
            --name "ai-content-dev-collector" \
            --resource-group "ai-content-dev-rg" \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)

          if [ -z "$URL" ]; then
            echo "[FAIL] Failed to get container app URL"
            exit 1
          fi

          echo "CONTENT_COLLECTOR_URL=https://$URL" >> "$GITHUB_OUTPUT"
          echo "[PASS] Content Collector URL: https://$URL"

      - name: Load Collection Template
        run: |
          # Load the specified collection template
          TEMPLATE_FILE="collection-templates/${{ env.COLLECTION_TEMPLATE }}"

          if [ ! -f "$TEMPLATE_FILE" ]; then
            echo "[ERROR] Template file not found: $TEMPLATE_FILE"
            echo "[INFO] Available templates:"
            ls -la collection-templates/
            exit 1
          fi

          echo "[INFO] Using collection template: $TEMPLATE_FILE"
          cp "$TEMPLATE_FILE" collection_request.json

          echo "[INFO] Collection request payload:"
          jq . collection_request.json

      - name: Send Collection Request
        run: |
          # Send collection request to the content collector API
          # This will trigger internal Service Bus processing and KEDA scaling
          echo "[INFO] Sending collection request to: ${{ steps.get-url.outputs.CONTENT_COLLECTOR_URL }}/collections"

          RESPONSE=$(curl -s -X POST "${{ steps.get-url.outputs.CONTENT_COLLECTOR_URL }}/collections" \
            -H "Content-Type: application/json" \
            -d @collection_request.json \
            -w "HTTPSTATUS:%{http_code}")

          HTTP_CODE="${RESPONSE##*HTTPSTATUS:}"
          RESPONSE_BODY="${RESPONSE%HTTPSTATUS:*}"

          echo "[INFO] HTTP Status: $HTTP_CODE"
          echo "[INFO] Response:"
          echo "$RESPONSE_BODY" | jq . || echo "$RESPONSE_BODY"

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "[ERROR] Collection request failed with status $HTTP_CODE"
            exit 1
          fi

          echo "[PASS] Content collection request sent successfully"
          echo "[INFO] Template used: ${{ env.COLLECTION_TEMPLATE }}"

      - name: Verify Collection Status
        run: |
          # Check the health and status of our collection
          echo "[INFO] Checking collection status..."

          curl -s "${{ steps.get-url.outputs.CONTENT_COLLECTOR_URL }}/status" | jq .

          echo "[PASS] Collection status checked"

      - name: Log Completion
        run: |
          echo "[COMPLETE] Content collection workflow completed"
          echo "[TEMPLATE] Used template: ${{ env.COLLECTION_TEMPLATE }}"
          echo "[SCHEDULE] Next scheduled run: $(date -d '+4 hours' -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "[MONITOR] Monitor processing at: ${{ steps.get-url.outputs.CONTENT_COLLECTOR_URL }}/health"
