name: Copilot Code Scanning Auto-Resolution

on:
  schedule:
    # Run daily at 10 AM UTC, after security monitoring
    - cron: '0 10 * * *'
  workflow_dispatch:
    inputs:
      target_alert_number:
        description: 'Target specific code scanning alert number'
        required: false
        type: string
      force_resolution:
        description: 'Force attempt resolution even for complex alerts'
        required: false
        default: 'false'
        type: boolean
      max_alerts:
        description: 'Maximum number of alerts to process in one run'
        required: false
        default: '5'
        type: string

permissions:
  contents: write
  security-events: read
  pull-requests: write
  issues: write
  actions: read

env:
  MAX_ALERTS: ${{ github.event.inputs.max_alerts || '5' }}
  FORCE_RESOLUTION: ${{ github.event.inputs.force_resolution || 'false' }}

jobs:
  analyze-code-scanning-alerts:
    name: Analyze Code Scanning Alerts
    runs-on: ubuntu-latest
    outputs:
      alerts-found: ${{ steps.scan.outputs.alerts-found }}
      resolvable-alerts: ${{ steps.scan.outputs.resolvable-alerts }}
      alert-matrix: ${{ steps.scan.outputs.alert-matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Analyze Code Scanning Alerts
        id: scan
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TARGET_ALERT: ${{ github.event.inputs.target_alert_number }}
        run: |
          echo "[SCAN] Analyzing code scanning alerts for auto-resolution..."

          # Get open code scanning alerts
          if [ -n "$TARGET_ALERT" ]; then
            echo "[TARGET] Focusing on alert #$TARGET_ALERT"
            alerts_json=$(gh api "repos/$REPO/code-scanning/alerts/$TARGET_ALERT" | jq -s '.')
          else
            alerts_json=$(gh api "repos/$REPO/code-scanning/alerts?state=open&per_page=$MAX_ALERTS")
          fi

          alerts_count=$(echo "$alerts_json" | jq 'length')
          echo "Found $alerts_count open code scanning alerts"

          if [ "$alerts_count" -eq 0 ]; then
            {
              echo "alerts-found=false"
              echo "resolvable-alerts=[]"
              echo "alert-matrix={\"include\":[]}"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Analyze alerts for auto-resolution potential
          alert_matrix=()

          echo "$alerts_json" | jq -c '.[]' | while IFS= read -r alert; do
            alert_number=$(echo "$alert" | jq -r '.number')
            rule_id=$(echo "$alert" | jq -r '.rule.id')
            rule_description=$(echo "$alert" | jq -r '.rule.description // "No description"')
            severity=$(echo "$alert" | jq -r '.rule.severity')
            file_path=$(echo "$alert" | jq -r '.most_recent_instance.location.path')

            echo "[ALERT] #$alert_number: $rule_id ($severity) in $file_path"

            # Determine if alert is suitable for auto-resolution
            auto_resolvable="false"
            resolution_strategy="manual"

            case "$rule_id" in
              # Python security patterns that are commonly auto-fixable
              "python.lang.security.insecure-hash-algorithms"|\
              "python.lang.security.weak-crypto"|\
              "python.lang.security.hardcoded-password"|\
              "python.django.security.injection.path-traversal"|\
              "python.flask.security.injection.path-traversal"|\
              "python.lang.security.sql-injection"|\
              "python.lang.security.subprocess-shell-true")
                auto_resolvable="true"
                resolution_strategy="security-fix"
                ;;

              # Code quality patterns
              "python.lang.correctness.unused-import"|\
              "python.lang.correctness.unused-variable"|\
              "python.lang.maintainability.todo-comment"|\
              "python.lang.performance.unnecessary-list-cast")
                if [ "$FORCE_RESOLUTION" = "true" ]; then
                  auto_resolvable="true"
                  resolution_strategy="code-quality"
                fi
                ;;

              # Infrastructure as Code patterns
              "terraform.azure.security.*"|\
              "yaml.github-actions.security.*")
                auto_resolvable="true"
                resolution_strategy="infrastructure-fix"
                ;;
            esac

            if [ "$auto_resolvable" = "true" ]; then
              echo "[CANDIDATE] Alert #$alert_number is candidate for auto-resolution ($resolution_strategy)"

              # Add to matrix for parallel processing
              matrix_item=$(jq -n \
                --arg alert_number "$alert_number" \
                --arg rule_id "$rule_id" \
                --arg severity "$severity" \
                --arg file_path "$file_path" \
                --arg strategy "$resolution_strategy" \
                --arg description "$rule_description" \
                '{
                  alert_number: $alert_number,
                  rule_id: $rule_id,
                  severity: $severity,
                  file_path: $file_path,
                  strategy: $strategy,
                  description: $description
                }')

              alert_matrix+=("$matrix_item")
            else
              echo "[SKIP] Alert #$alert_number requires manual review"
            fi
          done

          # Output results
          echo "alerts-found=true" >> "$GITHUB_OUTPUT"

          if [ ${#alert_matrix[@]} -gt 0 ]; then
            matrix_json=$(printf '%s\n' "${alert_matrix[@]}" | jq -s '{"include": .}')
            {
              echo "alert-matrix=$matrix_json"
              echo "resolvable-alerts=$(printf '%s\n' "${alert_matrix[@]}" | jq -s '.')"
            } >> "$GITHUB_OUTPUT"
            echo "[SUCCESS] Found ${#alert_matrix[@]} resolvable alerts"
          else
            {
              echo "alert-matrix={\"include\":[]}"
              echo "resolvable-alerts=[]"
            } >> "$GITHUB_OUTPUT"
            echo "[INFO] No alerts suitable for auto-resolution"
          fi

  auto-resolve-alerts:
    name: Auto-Resolve Alert
    runs-on: ubuntu-latest
    needs: analyze-code-scanning-alerts
    if: needs.analyze-code-scanning-alerts.outputs.alerts-found == 'true'
    strategy:
      matrix: ${{ fromJson(needs.analyze-code-scanning-alerts.outputs.alert-matrix) }}
      fail-fast: false
      max-parallel: 2
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Get Alert Details
        id: alert-details
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ALERT_NUMBER: ${{ matrix.alert_number }}
        run: |
          echo "[DETAILS] Fetching full details for alert #$ALERT_NUMBER"

          alert_data=$(gh api "repos/${{ github.repository }}/code-scanning/alerts/$ALERT_NUMBER")

          # Extract key information
          file_path=$(echo "$alert_data" | jq -r '.most_recent_instance.location.path')
          start_line=$(echo "$alert_data" | jq -r '.most_recent_instance.location.start_line')
          end_line=$(echo "$alert_data" | jq -r '.most_recent_instance.location.end_line')
          message=$(echo "$alert_data" | jq -r '.most_recent_instance.message.text')

          {
            echo "file-path=$file_path"
            echo "start-line=$start_line"
            echo "end-line=$end_line"
            echo "message=$message"
          } >> "$GITHUB_OUTPUT"

          echo "[FILE] $file_path (lines $start_line-$end_line)"
          echo "[ISSUE] $message"

      - name: Create Copilot Resolution Branch
        id: create-branch
        shell: bash
        env:
          ALERT_NUMBER: ${{ matrix.alert_number }}
          RULE_ID: ${{ matrix.rule_id }}
        run: |
          # Create descriptive branch name
          sanitized_rule=$(echo "$RULE_ID" | sed 's/[^a-zA-Z0-9-]/-/g' | sed 's/--*/-/g')
          full_branch_name="copilot/fix-${sanitized_rule}-${ALERT_NUMBER}"

          echo "[BRANCH] Creating branch: $full_branch_name"
          git checkout -b "$full_branch_name"

          echo "branch-name=$full_branch_name" >> "$GITHUB_OUTPUT"

      - name: Apply Copilot Auto-Fix
        id: apply-fix
        shell: bash
        env:
          ALERT_NUMBER: ${{ matrix.alert_number }}
          RULE_ID: ${{ matrix.rule_id }}
          STRATEGY: ${{ matrix.strategy }}
          FILE_PATH: ${{ steps.alert-details.outputs.file-path }}
          START_LINE: ${{ steps.alert-details.outputs.start-line }}
          END_LINE: ${{ steps.alert-details.outputs.end-line }}
          ISSUE_MESSAGE: ${{ steps.alert-details.outputs.message }}
        run: |
          echo "[FIX] Applying auto-fix for $RULE_ID using strategy: $STRATEGY"

          # Create a detailed prompt for the fix
          cat > copilot_fix_prompt.md << EOF
          # Code Scanning Alert Auto-Fix Request

          **Alert ID**: #$ALERT_NUMBER
          **Rule**: $RULE_ID
          **Strategy**: $STRATEGY
          **File**: $FILE_PATH
          **Lines**: $START_LINE-$END_LINE
          **Issue**: $ISSUE_MESSAGE

          ## Context
          This is an automated fix for a code scanning alert. The fix should:
          1. Address the specific security/quality issue identified
          2. Follow best practices for the detected pattern
          3. Maintain code functionality
          4. Be minimal and focused

          ## Current Code
          \`\`\`
          $(sed -n "${START_LINE},${END_LINE}p" "$FILE_PATH" 2>/dev/null || echo "Could not read file")
          \`\`\`

          Please provide a targeted fix for this specific issue.
          EOF

          # Apply strategy-specific fixes
          case "$STRATEGY" in
            "security-fix")
              echo "[SECURITY] Applying security-focused fix"
              # Use GitHub Copilot CLI for security fixes
              # Note: This would integrate with GitHub Copilot CLI when available
              # For now, apply common security fix patterns

              case "$RULE_ID" in
                *"insecure-hash-algorithms"*)
                  echo "[FIX] Replacing insecure hash algorithms"
                  sed -i 's/hashlib\.md5/hashlib.sha256/g' "$FILE_PATH"
                  sed -i 's/hashlib\.sha1/hashlib.sha256/g' "$FILE_PATH"
                  ;;
                *"hardcoded-password"*)
                  echo "[FIX] Removing hardcoded passwords"
                  # This would require more sophisticated analysis
                  echo "# TODO: Replace hardcoded password with environment variable or secret management" >> "$FILE_PATH.fix_notes"
                  ;;
                *"path-traversal"*)
                  echo "[FIX] Adding path traversal protection"
                  # Add import for secure path handling if not present
                  if ! grep -q "import os.path" "$FILE_PATH"; then
                    sed -i '1i import os.path' "$FILE_PATH"
                  fi
                  ;;
              esac
              ;;

            "code-quality")
              echo "[QUALITY] Applying code quality fix"
              case "$RULE_ID" in
                *"unused-import"*)
                  echo "[FIX] Removing unused imports"
                  # Use isort and autoflake to clean up imports
                  pip install -q autoflake isort
                  autoflake --remove-all-unused-imports --in-place "$FILE_PATH" || true
                  isort "$FILE_PATH" || true
                  ;;
                *"unused-variable"*)
                  echo "[FIX] Handling unused variables"
                  # Prefix unused variables with underscore
                  # This requires more sophisticated parsing
                  ;;
              esac
              ;;

            "infrastructure-fix")
              echo "[INFRA] Applying infrastructure fix"
              # Apply common Terraform/YAML security fixes
              ;;
          esac

          # Check if any changes were made
          if git diff --quiet; then
            echo "fix-applied=false" >> "$GITHUB_OUTPUT"
            echo "[SKIP] No automated fix could be applied"
          else
            echo "fix-applied=true" >> "$GITHUB_OUTPUT"
            echo "[SUCCESS] Automated fix applied"

            # Show what changed
            echo "[CHANGES]"
            git diff --no-color
          fi

      - name: Validate Fix
        if: steps.apply-fix.outputs.fix-applied == 'true'
        id: validate
        shell: bash
        env:
          FILE_PATH: ${{ steps.alert-details.outputs.file-path }}
        run: |
          echo "[VALIDATE] Running basic validation on fixed code"

          validation_passed="true"

          # Basic syntax check for Python files
          if [[ "$FILE_PATH" == *.py ]]; then
            if ! python -m py_compile "$FILE_PATH"; then
              echo "[ERROR] Python syntax validation failed"
              validation_passed="false"
            fi
          fi

          # Basic YAML validation
          if [[ "$FILE_PATH" == *.yml ]] || [[ "$FILE_PATH" == *.yaml ]]; then
            if command -v yamllint >/dev/null 2>&1; then
              if ! yamllint "$FILE_PATH"; then
                echo "[ERROR] YAML validation failed"
                validation_passed="false"
              fi
            fi
          fi

          echo "validation-passed=$validation_passed" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request
        if: steps.apply-fix.outputs.fix-applied == 'true' && steps.validate.outputs.validation-passed == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH_NAME: ${{ steps.create-branch.outputs.branch-name }}
          ALERT_NUMBER: ${{ matrix.alert_number }}
          RULE_ID: ${{ matrix.rule_id }}
          SEVERITY: ${{ matrix.severity }}
          FILE_PATH: ${{ steps.alert-details.outputs.file-path }}
          DESCRIPTION: ${{ matrix.description }}
        run: |
          echo "[PR] Creating pull request for auto-fix"

          # Commit the changes
          git add -A
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "fix: auto-resolve code scanning alert #${ALERT_NUMBER}

          - Rule: ${RULE_ID}
          - Severity: ${SEVERITY}
          - File: ${FILE_PATH}
          - Description: ${DESCRIPTION}

          This fix was automatically generated by GitHub Copilot
          to address the code scanning alert. Please review the
          changes before merging.

          Fixes code scanning alert #${ALERT_NUMBER}"

          # Push the branch
          git push origin "$BRANCH_NAME"

          # Create pull request
          pr_body="## [AUTOMATED] Automated Code Scanning Fix

          This PR automatically resolves code scanning alert **#${ALERT_NUMBER}**.

          ### Alert Details
          - **Rule**: \`${RULE_ID}\`
          - **Severity**: \`${SEVERITY}\`
          - **File**: \`${FILE_PATH}\`
          - **Description**: ${DESCRIPTION}

          ### Changes Made
          This fix was automatically generated using GitHub Copilot to address the identified security/quality issue.

          ### Validation
          [PASS] Basic syntax/format validation passed
          [PASS] Changes are minimal and focused

          ### Next Steps
          1. Review the changes carefully
          2. Test the functionality if needed
          3. Merge if the fix is appropriate
          4. Close the code scanning alert manually if needed

          ---
          *This PR was created automatically by the Copilot Code Scanning Auto-Resolution workflow.*"

          gh pr create \
            --title "[AUTOMATED] Auto-fix: Resolve code scanning alert #${ALERT_NUMBER} (${RULE_ID})" \
            --body "$pr_body" \
            --label "automated-fix,code-scanning,copilot" \
            --base main \
            --head "$BRANCH_NAME"

          echo "[SUCCESS] Pull request created for alert #${ALERT_NUMBER}"

      - name: Comment on Failure
        if: steps.apply-fix.outputs.fix-applied == 'false' || steps.validate.outputs.validation-passed == 'false'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ALERT_NUMBER: ${{ matrix.alert_number }}
        run: |
          echo "[COMMENT] Adding comment about failed auto-resolution"

          # Note: GitHub doesn't allow direct comments on code scanning alerts via API
          # Create an issue instead for tracking
          gh issue create \
            --title "[AUTOMATED] Auto-fix failed for code scanning alert #${ALERT_NUMBER}" \
            --label "automated-fix,failed,code-scanning" \
            --body "The automated fix attempt for code scanning alert #${ALERT_NUMBER} was unsuccessful. Manual review is required.

          **Alert**: #${ALERT_NUMBER}
          **Rule**: ${{ matrix.rule_id }}
          **File**: ${{ steps.alert-details.outputs.file-path }}

          Please review this alert manually."

  summary:
    name: Resolution Summary
    runs-on: ubuntu-latest
    needs: [analyze-code-scanning-alerts, auto-resolve-alerts]
    if: always()
    steps:
      - name: Generate Summary
        shell: bash
        env:
          ALERTS_FOUND: ${{ needs.analyze-code-scanning-alerts.outputs.alerts-found }}
          RESOLVABLE_ALERTS: ${{ needs.analyze-code-scanning-alerts.outputs.resolvable-alerts }}
        run: |
          echo "## [AUTOMATED] Copilot Code Scanning Auto-Resolution Summary"

          if [ "$ALERTS_FOUND" = "true" ]; then
            alert_count=$(echo "$RESOLVABLE_ALERTS" | jq 'length')
            echo "- **Alerts analyzed**: $alert_count"
            echo "- **Auto-resolution attempted**: Yes"
            echo "- **Status**: Check individual job results for details"
          else
            echo "- **Status**: No open code scanning alerts found"
          fi

          echo ""
          echo "### Next Steps"
          echo "1. Review any created pull requests"
          echo "2. Test the proposed fixes"
          echo "3. Merge approved fixes"
          echo "4. Handle any failed auto-resolution attempts manually"
