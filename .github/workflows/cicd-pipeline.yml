name: CI/CD Pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
    paths-ignore:
      - '.github/workflows/**'
      - '.github/actions/**'
      - '**.md'
      - 'docs/**'

permissions:
  contents: read
  security-events: write
  pull-requests: write
  issues: write
  actions: read
  checks: write
  packages: write
  id-token: write

env:
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain

jobs:
  # Skip CI/CD for Dependabot PRs (they have their own lightweight workflow)
  check-actor:
    if: github.actor != 'dependabot[bot]'
    runs-on: ubuntu-latest
    steps:
      - run: echo "Running CI/CD for non-Dependabot PR"

  # Stage 1: Change Detection & Job Planning
  plan-pipeline:
    name: Plan Pipeline Execution
    runs-on: ubuntu-latest
    needs: check-actor
    outputs:
      skip-deployment: ${{ steps.plan.outputs.skip-deployment }}
      changed-containers: ${{ steps.plan.outputs.changed-containers }}
      needs-infrastructure: ${{ steps.plan.outputs.needs-infrastructure }}
      needs-security-scan: ${{ steps.plan.outputs.needs-security-scan }}
      test-matrix: ${{ steps.plan.outputs.test-matrix }}
      deployment-method: ${{ steps.plan.outputs.deployment-method }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Plan Pipeline Execution
        id: plan
        shell: bash
        run: |
          echo "[SCAN] Analyzing changes to plan pipeline execution..."

          # Get changed files with multiple fallback methods
          changed_files=""

          if [ -z "$changed_files" ]; then
            changed_files=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          fi

          if [ -z "$changed_files" ]; then
            changed_files=$(git diff --name-only origin/main HEAD 2>/dev/null || echo "")
          fi

          if [ -z "$changed_files" ]; then
            changed_files=$(git show --name-only --format="" HEAD 2>/dev/null || echo "")
          fi

          echo "[FILES] Changed files:"
          echo "$changed_files"

          # Initialize decision variables
          skip_deployment=false
          changed_containers="[]"
          needs_infrastructure=false
          needs_security_scan=false
          deployment_method="skip"

          # Analyze each changed file
          declare -A container_set
          has_code_changes=false
          has_only_docs=true

          while IFS= read -r file; do
            if [[ -z "$file" ]]; then continue; fi

            if [[ "$file" =~ ^containers/([^/]+)/ ]]; then
              container_name="${BASH_REMATCH[1]}"
              # Only include containers that actually exist and have a Dockerfile
              if [[ -d "containers/$container_name" && -f "containers/$container_name/Dockerfile" ]]; then
                # Skip base container as it's not a deployable service
                if [[ "$container_name" != "base" && "$container_name" != "__pycache__" ]]; then
                  container_set["$container_name"]=1
                  has_code_changes=true
                  has_only_docs=false
                  echo "[CONTAINER] Container change: $container_name"
                fi
              else
                echo "[SKIP] Ignoring deleted/non-existent container: $container_name"
              fi
            elif [[ "$file" =~ ^libs/ ]] || [[ "$file" =~ ^requirements.*\.txt$ ]] || [[ "$file" == "pyproject.toml" ]]; then
              # Libs affect all containers - dynamically discover existing containers
              echo "[LIBRARY] Library change affects all containers - discovering available containers..."

              # Use our discovery script for robust container detection
              if [[ -x "./scripts/discover-containers.sh" ]]; then
                echo "[DISCOVERY] Using container discovery script..."
                while IFS= read -r container_name; do
                  container_set["$container_name"]=1
                  echo "[DISCOVERY] Found container: $container_name"
                done < <(./scripts/discover-containers.sh --list)
              else
                echo "[FALLBACK] Discovery script not found, using manual discovery..."
                for container_dir in containers/*/; do
                  if [[ -d "$container_dir" && -f "$container_dir/Dockerfile" ]]; then
                    container_name=$(basename "$container_dir")
                    # Skip base container as it's not a deployable service
                    if [[ "$container_name" != "base" && "$container_name" != "__pycache__" ]]; then
                      container_set["$container_name"]=1
                      echo "[DISCOVERY] Found container: $container_name"
                    fi
                  fi
                done
              fi

              has_code_changes=true
              has_only_docs=false
              echo "[LIBRARY] Library change affects all discovered containers"
            elif [[ "$file" =~ ^infra/ ]] || [[ "$file" =~ \.tf$ ]]; then
              needs_infrastructure=true
              has_only_docs=false
              echo "[INFRA] Infrastructure change: $file"
            elif [[ "$file" =~ ^(docs/|\.md$|\.github/workflows/|\.github/actions/|scripts/|\.pre-commit) ]]; then
              echo "[DOC] Non-deployment change: $file"
            else
              has_code_changes=true
              has_only_docs=false
              echo "[UNKNOWN] Other change: $file"
            fi
          done <<< "$changed_files"

          # Add Docker consistency validation when Docker-related files change
          echo "[DOCKER] Checking for Docker-related changes..."
          if echo "$changed_files" | grep -E "(Dockerfile|docker-compose|containers/)" > /dev/null; then
            container_set["docker-consistency"]=1
            echo "[DOCKER] Docker-related changes detected - adding docker-consistency tests"
          fi

          # Convert container set to JSON array
          if [[ ${#container_set[@]} -gt 0 ]]; then
            containers_json=$(printf '"%s",' "${!container_set[@]}" | sed 's/,$//')
            changed_containers="[$containers_json]"
          fi

          # Determine security scan needs
          if [[ "$has_code_changes" == true ]] || [[ "$needs_infrastructure" == true ]]; then
            needs_security_scan=true
          fi

          # Determine deployment method
          if [[ "$has_only_docs" == true ]]; then
            skip_deployment=true
            deployment_method="skip"
          elif [[ "$has_code_changes" == true ]] && [[ "$needs_infrastructure" == false ]]; then
            deployment_method="container-update"
          elif [[ "$needs_infrastructure" == true ]]; then
            deployment_method="terraform"
          else
            skip_deployment=true
            deployment_method="skip"
          fi

          # Generate test matrix for parallel execution
          test_matrix="$changed_containers"

          echo "[STATS] Pipeline Plan:"
          echo "skip-deployment=$skip_deployment"
          echo "changed-containers=$changed_containers"
          echo "needs-infrastructure=$needs_infrastructure"
          echo "needs-security-scan=$needs_security_scan"
          echo "test-matrix=$test_matrix"
          echo "deployment-method=$deployment_method"

          # Set outputs
          {
            echo "skip-deployment=$skip_deployment"
            echo "changed-containers=$changed_containers"
            echo "needs-infrastructure=$needs_infrastructure"
            echo "needs-security-scan=$needs_security_scan"
            echo "test-matrix=$test_matrix"
            echo "deployment-method=$deployment_method"
          } >> "$GITHUB_OUTPUT"

  # Stage 2: Workflow Validation (Always Required)
  workflow-validation:
    name: Validate Workflows
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Validate Workflows
        uses: ./.github/actions/lint-workflows

  # Stage 3: Conditional Container Testing
  test-containers:
    name: Test ${{ matrix.container }}
    runs-on: ubuntu-latest
    needs: [plan-pipeline, workflow-validation]
    if: needs.plan-pipeline.outputs.changed-containers != '[]' && needs.workflow-validation.result == 'success'
    strategy:
      matrix:
        container: ${{ fromJson(needs.plan-pipeline.outputs.changed-containers) }}
      fail-fast: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Test Container (${{ matrix.container }})
        uses: ./.github/actions/test-single-container
        with:
          container-name: ${{ matrix.container }}
          test-type: unit
          upload-coverage: 'true'

      - name: Integration Test Container (${{ matrix.container }})
        if: hashFiles(format('containers/{0}/tests/test_integration*.py', matrix.container)) != ''
        uses: ./.github/actions/test-single-container
        with:
          container-name: ${{ matrix.container }}
          test-type: integration
          upload-coverage: 'false'

  # Stage 4: Conditional Security Scans
  security-scans:
    name: Security Scans
    runs-on: ubuntu-latest
    needs: [plan-pipeline, workflow-validation]
    if: needs.plan-pipeline.outputs.needs-security-scan == 'true' && needs.workflow-validation.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Run Comprehensive Security Scan
        uses: ./.github/actions/security-scan
        with:
          fail-on-critical: 'false'  # Allow pipeline to continue, but report issues
          upload-sarif: 'true'
          environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}

  # Stage 5: Conditional Infrastructure Quality
  infrastructure-quality:
    name: Infrastructure Quality
    runs-on: ubuntu-latest
    needs: [plan-pipeline, workflow-validation]
    if: needs.plan-pipeline.outputs.needs-infrastructure == 'true' && needs.workflow-validation.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Run Infrastructure Quality Checks
        uses: ./.github/actions/infrastructure-quality
        with:
          infra-changed: 'true'

      - name: Run Checkov Infrastructure Scan
        uses: ./.github/actions/security-checkov

      - name: Analyze Infrastructure Costs
        uses: ./.github/actions/cost-analysis
        with:
          infracost-api-key: ${{ secrets.INFRACOST_API_KEY }}
          comment-on-pr: ${{ github.event_name == 'pull_request' && 'true' || 'false' }}

  # Stage 6: Code Quality (Only for Code Changes)
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    needs: [plan-pipeline, workflow-validation]
    if: needs.plan-pipeline.outputs.changed-containers != '[]' && needs.workflow-validation.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Auto-fix Code Formatting
        if: github.event_name == 'pull_request'
        uses: ./.github/actions/auto-fix-formatting

      - name: Run Code Quality Checks
        uses: ./.github/actions/code-quality

  # Stage 7: Conditional Container Builds
  build-containers:
    name: Build ${{ matrix.container }}
    runs-on: ubuntu-latest
    needs: [plan-pipeline, test-containers, security-scans, code-quality]
    if: |
      always() &&
      needs.plan-pipeline.outputs.changed-containers != '[]' &&
      needs.test-containers.result == 'success' &&
      (needs.security-scans.result == 'success' || needs.security-scans.result == 'skipped') &&
      (needs.code-quality.result == 'success' || needs.code-quality.result == 'skipped')
    strategy:
      matrix:
        container: ${{ fromJson(needs.plan-pipeline.outputs.changed-containers) }}
      fail-fast: false
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Container (${{ matrix.container }})
        uses: ./.github/actions/build-and-push-container
        with:
          container-name: ${{ matrix.container }}
          registry: 'ghcr.io'
          repository: 'hardcoreprawn/ai-content-farm'
          tag: ${{ github.sha }}
          enable-cache: 'true'

  # Stage 8: Deployment Planning
  prepare-deployment:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    needs: [plan-pipeline, build-containers, infrastructure-quality]
    if: |
      always() &&
      needs.plan-pipeline.outputs.skip-deployment == 'false' &&
      needs.plan-pipeline.outputs.deployment-method == 'container-update' &&
      (needs.build-containers.result == 'success' || needs.build-containers.result == 'skipped' || needs.plan-pipeline.outputs.changed-containers == '[]') &&
      (needs.infrastructure-quality.result == 'success' || needs.infrastructure-quality.result == 'skipped')
    outputs:
      registry-images: ${{ steps.collect.outputs.registry-images }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Collect Build Results
        id: collect
        uses: ./.github/actions/collect-build-summary
        with:
          build-jobs: ${{ toJson(needs.build-containers) }}
          registry: 'ghcr.io'
          commit-sha: ${{ github.sha }}

  # Stage 9: Conditional Deployment
  # Debug: Test deployment job conditions
  debug-deployment:
    name: Debug Deployment Conditions
    runs-on: ubuntu-latest
    needs: [plan-pipeline]
    if: always()
    steps:
      - name: Debug Deployment Conditions
        run: |
          echo "=== DEPLOYMENT CONDITION DEBUG ==="
          echo "needs-infrastructure: '${{ needs.plan-pipeline.outputs.needs-infrastructure }}'"
          echo "deployment-method: '${{ needs.plan-pipeline.outputs.deployment-method }}'"
          echo "skip-deployment: '${{ needs.plan-pipeline.outputs.skip-deployment }}'"
          echo ""
          echo "=== CONDITION EVALUATIONS ==="
          echo "needs-infrastructure == 'true': ${{ needs.plan-pipeline.outputs.needs-infrastructure == 'true' }}"
          echo "deployment-method == 'terraform': ${{ needs.plan-pipeline.outputs.deployment-method == 'terraform' }}"
          echo ""
          echo "Should deploy-infrastructure run? ${{ needs.plan-pipeline.outputs.needs-infrastructure == 'true' }}"

  deploy-infrastructure:
    name: Deploy (Full Terraform)
    runs-on: ubuntu-latest
    needs: [plan-pipeline, infrastructure-quality, build-containers]
    if: |
      needs.plan-pipeline.outputs.needs-infrastructure == 'true' &&
      needs.plan-pipeline.outputs.deployment-method == 'terraform' &&
      needs.infrastructure-quality.result == 'success' &&
      (needs.build-containers.result == 'success' || needs.build-containers.result == 'skipped')
    outputs:
      deployment-url: ${{ steps.terraform-deploy.outputs.deployment-url }}
    steps:
      - name: Debug Before Deploy
        run: |
          echo "[DEPLOY] Starting Terraform deployment..."
          echo "Branch: ${{ github.ref }}"
          echo "Deployment method: ${{ needs.plan-pipeline.outputs.deployment-method }}"
          echo "Infrastructure quality result: ${{ needs.infrastructure-quality.result }}"

      - name: Checkout code
        uses: actions/checkout@v5

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Full Terraform Deployment
        id: terraform-deploy
        uses: ./.github/actions/smart-deploy
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          environment: production
          registry-images: "[]"
          terraform-storage-account: ${{ vars.TERRAFORM_STATE_STORAGE_ACCOUNT_PROD || 'aicontentfarmtfstate' }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

  deploy-containers:
    name: Deploy (Container Update)
    runs-on: ubuntu-latest
    needs: [plan-pipeline, prepare-deployment]
    if: |
      needs.plan-pipeline.outputs.deployment-method == 'container-update' &&
      needs.plan-pipeline.outputs.needs-infrastructure == 'false'
    outputs:
      deployment-url: ${{ steps.fast-deploy.outputs.deployment-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Fast Container Deployment
        id: fast-deploy
        uses: ./.github/actions/fast-container-deploy
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          environment: production
          registry-images: ${{ needs.prepare-deployment.outputs.registry-images }}

  # Stage 9.5: Sync Container Images (handles race condition between Terraform and container builds)
  sync-containers:
    name: Sync Container Images
    runs-on: ubuntu-latest
    needs: [plan-pipeline, deploy-infrastructure, build-containers]
    if: |
      always() &&
      needs.deploy-infrastructure.result == 'success' &&
      needs.build-containers.result == 'success' &&
      needs.plan-pipeline.outputs.changed-containers != '[]'
    outputs:
      sync-results: ${{ steps.sync.outputs.sync-results }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Sync Container Images
        id: sync
        uses: ./.github/actions/sync-container-images
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          resource-group: 'ai-content-prod-rg'
          registry-images: ${{ needs.plan-pipeline.outputs.changed-containers }}
          container-app-prefix: 'ai-content-prod'
          registry: 'ghcr.io'
          repository: 'hardcoreprawn/ai-content-farm'
          image-tag: ${{ github.sha }}

  # Stage 10: Post-Deployment Validation
  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-latest
    needs: [deploy-containers, deploy-infrastructure, sync-containers]
    if: |
      always() &&
      (needs.deploy-containers.result == 'success' || needs.deploy-infrastructure.result == 'success') &&
      (needs.sync-containers.result == 'success' || needs.sync-containers.result == 'skipped')
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Post-Deployment Tests
        uses: ./.github/actions/post-deployment
        with:
          deployment-url: ${{ needs.deploy-containers.outputs.deployment-url || needs.deploy-infrastructure.outputs.deployment-url }}

  # Stage 11: Pipeline Summary
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [plan-pipeline, workflow-validation, test-containers, security-scans, infrastructure-quality, code-quality, build-containers, deploy-containers, deploy-infrastructure, sync-containers, validate-deployment]
    if: always()
    steps:
      - name: Generate Pipeline Summary
        shell: bash
        run: |
          {
            echo "# [DEPLOY] CI/CD Pipeline Summary"
            echo ""
            echo "## [PLAN] Execution Plan"
            echo "- **Deployment Method**: ${{ needs.plan-pipeline.outputs.deployment-method }}"
            echo "- **Changed Containers**: ${{ needs.plan-pipeline.outputs.changed-containers }}"
            echo "- **Infrastructure Changes**: ${{ needs.plan-pipeline.outputs.needs-infrastructure }}"
            echo "- **Security Scans**: ${{ needs.plan-pipeline.outputs.needs-security-scan }}"
            echo ""
            echo "## [STATS] Job Results"
            echo "| Stage | Result |"
            echo "|-------|--------|"
            echo "| Workflow Validation | ${{ needs.workflow-validation.result }} |"
            echo "| Container Tests | ${{ needs.test-containers.result }} |"
            echo "| Security Scans | ${{ needs.security-scans.result }} |"
            echo "| Infrastructure Quality | ${{ needs.infrastructure-quality.result }} |"
            echo "| Code Quality | ${{ needs.code-quality.result }} |"
            echo "| Container Builds | ${{ needs.build-containers.result }} |"
            echo "| Container Deployment | ${{ needs.deploy-containers.result }} |"
            echo "| Infrastructure Deployment | ${{ needs.deploy-infrastructure.result }} |"
            echo "| Deployment Validation | ${{ needs.validate-deployment.result }} |"
          } >> "$GITHUB_STEP_SUMMARY"
