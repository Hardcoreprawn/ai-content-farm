name: Consolidated CI/CD Pipeline

on:
  push:
    branches: [ develop, main ]
    paths:
      - 'functions/**'
      - 'infra/**'
      - 'tests/**'
      - 'pytest.ini'
      - 'requirements.txt'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'functions/**'
      - 'infra/**'
      - 'tests/**'
      - 'pytest.ini'
      - 'requirements.txt'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_security:
        description: 'Skip security checks (use with caution)'
        required: false
        default: false
        type: boolean
      skip_cost:
        description: 'Skip cost checks (when Infracost unavailable)'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip integration tests (for urgent deployments)'
        required: false
        default: false
        type: boolean

# OIDC permissions for Azure authentication
permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

env:
  AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}

jobs:
  # Detect changes for conditional execution
  changes:
    runs-on: ubuntu-latest
    outputs:
      infrastructure: ${{ steps.changes.outputs.infrastructure }}
      functions: ${{ steps.changes.outputs.functions }}
      tests: ${{ steps.changes.outputs.tests }}
      docs: ${{ steps.changes.outputs.docs }}
      workflows: ${{ steps.changes.outputs.workflows }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            infrastructure:
              - 'infra/**'
            functions:
              - 'functions/**'
            tests:
              - 'tests/**'
              - 'pytest.ini'
              - 'requirements.txt'
            docs:
              - 'docs/**'
              - '*.md'
            workflows:
              - '.github/workflows/**'
              - '.yamllint.yaml'

  # Workflow Validation (for workflow changes)
  workflow-lint:
    if: ${{ needs.changes.outputs.workflows == 'true' }}
    runs-on: ubuntu-latest
    name: YAML and Actions Lint
    needs: changes
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
          cache: 'pip'

      - name: Install yamllint
        run: pip install yamllint

      - name: Run yamllint
        run: yamllint -f colored .

      - name: Run actionlint
        uses: docker://rhysd/actionlint:latest
        with:
          args: -color

  # Stage 1: Parallel Validation Gates
  security-gate:
    # Skip security scans for docs-only changes (no infrastructure, functions, tests, or workflows)
    if: >
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
      (github.event.inputs.skip_security != 'true') &&
      (needs.changes.outputs.infrastructure == 'true' ||
       needs.changes.outputs.functions == 'true' ||
       needs.changes.outputs.tests == 'true' ||
       needs.changes.outputs.workflows == 'true')
    runs-on: ubuntu-latest
    name: Security and Compliance Validation
    needs: changes
    outputs:
      security-approved: ${{ steps.security-gate.outputs.approved }}
      critical-findings: ${{ steps.security-gate.outputs.critical-findings }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Cache Security Tools
        id: cache-security-tools
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/bin/tfsec
            /usr/local/bin/terrascan
            /usr/local/bin/syft
          key: security-tools-${{ runner.os }}-v2

      - name: Install Security Tools
        if: steps.cache-security-tools.outputs.cache-hit != 'true'
        run: |
          # Install tools in parallel for speed
          {
            pip3 install checkov &
            PIP_PID=$!

            # Install tfsec
            wget -O tfsec https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64 \
              && chmod +x tfsec && sudo mv tfsec /usr/local/bin &
            TFSEC_PID=$!

            # Install terrascan
            LATEST_URL=$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E "https://.*Linux_x86_64.tar.gz" | head -1)
            curl -L "$LATEST_URL" > terrascan.tar.gz \
              && tar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz \
              && sudo mv terrascan /usr/local/bin &
            TERRASCAN_PID=$!

            # Install syft
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin &
            SYFT_PID=$!

            # Wait for all installations
            wait $PIP_PID $TFSEC_PID $TERRASCAN_PID $SYFT_PID
          }

      - name: Ensure tools are available (from cache or fresh install)
        run: |
          pip3 install checkov

      - name: Run Security Scans (Parallel)
        id: security-scans
        continue-on-error: true
        run: |
          echo "Running comprehensive security scans in parallel..."
          mkdir -p security-results

          # Run scans in parallel for faster execution
          {
            # Checkov - infrastructure
            checkov -d infra --quiet --compact --output json --output-file-path security-results/checkov.json &
            CHECKOV_INFRA_PID=$!

            # Checkov - functions
            checkov -d functions --quiet --compact --output json --output-file-path security-results/checkov-functions.json &
            CHECKOV_FUNC_PID=$!

            # TFSec
            (cd infra/application && tfsec . --format json --out ../../security-results/tfsec.json --soft-fail) &
            TFSEC_PID=$!

            # Terrascan
            (cd infra/application && terrascan scan -i terraform --output json > ../../security-results/terrascan.json) &
            TERRASCAN_PID=$!

            # SBOM generation
            syft functions -o json=security-results/sbom.json &
            SBOM_PID=$!

            # Wait for all scans to complete
            wait $CHECKOV_INFRA_PID $CHECKOV_FUNC_PID $TFSEC_PID $TERRASCAN_PID $SBOM_PID
          }

          echo "All security scans completed"

      - name: Security Gate Decision
        id: security-gate
        run: |
          mkdir -p security-results

          # Analyze security scan results
          CRITICAL_COUNT=0
          HIGH_COUNT=0

          # Check Checkov results for critical/high findings
          if [ -f security-results/checkov.json ]; then
            CRITICAL_COUNT=$(
              jq \
                '.results.failed_checks
                 | map(select(.severity == "CRITICAL"))
                 | length' \
                security-results/checkov.json 2>/dev/null \
              || echo 0
            )
            HIGH_COUNT=$(
              jq \
                '.results.failed_checks
                 | map(select(.severity == "HIGH"))
                 | length' \
                security-results/checkov.json 2>/dev/null \
              || echo 0
            )
          fi

          echo "Critical findings: $CRITICAL_COUNT"
          echo "High findings: $HIGH_COUNT"
          echo "critical-findings=$CRITICAL_COUNT" >> "$GITHUB_OUTPUT"

          # Simplified security gate logic - pass or fail
          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "❌ SECURITY GATE FAILED: $CRITICAL_COUNT critical security findings detected"
            echo "approved=false" >> "$GITHUB_OUTPUT"
            exit 1
          elif [ "$HIGH_COUNT" -gt 10 ]; then
            echo "❌ SECURITY GATE FAILED: $HIGH_COUNT high-severity findings exceed limit (>10)"
            echo "approved=false" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "✅ SECURITY GATE PASSED: No critical findings, $HIGH_COUNT high findings"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload Security Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: security-results/
          retention-days: 30

  # Stage 2: Cost Impact Analysis (Parallel with Security, Infrastructure changes only)
  cost-gate:
    if: >
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
      (github.event.inputs.skip_cost != 'true') &&
      needs.changes.outputs.infrastructure == 'true'
    runs-on: ubuntu-latest
    name: Cost Impact and Budget Approval
    needs: changes
    outputs:
      cost-approved: ${{ steps.cost-gate.outputs.approved }}
      estimated-cost: ${{ steps.cost-gate.outputs.estimated-cost }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Cache Terraform Providers
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/application/.terraform
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('infra/application/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-providers-${{ runner.os }}-

      - name: Install Infracost (Cached)
        uses: infracost/actions/setup@v3
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY || 'ico-free-tier-key' }}
          version: 0.10.38

      - name: Fast Terraform Plan for Cost Analysis
        id: terraform-plan
        run: |
          cd infra/application

          # Configure backend for remote state with caching
          ENV_INPUT="${{ github.event.inputs.environment }}"
          if [ -z "$ENV_INPUT" ]; then ENV_INPUT="staging"; fi

          # Use cached terraform if available
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          mkdir -p $TF_PLUGIN_CACHE_DIR

          if [ "$ENV_INPUT" = "production" ]; then
            terraform init -backend-config=backend-production.hcl
          else
            terraform init -backend-config=backend-staging.hcl
          fi

          # Create terraform plan optimized for cost analysis
          echo "🔧 Creating optimized Terraform plan for cost analysis..."
          if terraform plan -out=tfplan -var="environment=${{ github.event.inputs.environment || 'staging' }}" -refresh=false 2>&1 | tee plan.log; then
            echo "Terraform plan successful"
            PLAN_SUCCESS=true
          else
            echo "Terraform plan had issues, checking if they're permission-related..."
            PLAN_SUCCESS=false

            # Check if errors are related to Key Vault permissions (expected on first deployment)
            if grep -q "does not have secrets get permission\|Authorization_RequestDenied" plan.log; then
              echo "Detected expected permission errors for first deployment - proceeding"
              PLAN_SUCCESS=true
            fi
          fi

          if [ "$PLAN_SUCCESS" = "false" ]; then
            echo "Terraform plan failed with non-permission errors"
            cat plan.log
            exit 1
          fi

          # Fast Infracost analysis
          echo "Running fast cost analysis..."
          mkdir -p ../cost-analysis

          if infracost breakdown --path tfplan --format json > ../cost-analysis/infracost.json 2>&1; then
            ESTIMATED_COST=$(jq -r '.totalMonthlyCost' ../cost-analysis/infracost.json 2>/dev/null || echo "unavailable")
            echo "estimated-cost=$ESTIMATED_COST" >> "$GITHUB_OUTPUT"
            echo "cost-available=true" >> "$GITHUB_OUTPUT"
          else
            echo "estimated-cost=unavailable" >> "$GITHUB_OUTPUT"
            echo "cost-available=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Cost Gate Decision
        id: cost-gate
        run: |
          ESTIMATED_COST="${{ steps.terraform-plan.outputs.estimated-cost }}"
          COST_AVAILABLE="${{ steps.terraform-plan.outputs.cost-available }}"

          # Fast cost gate decision
          if [ "$COST_AVAILABLE" = "false" ] || [ "$ESTIMATED_COST" = "unavailable" ]; then
            echo "⚠️  Cost estimation unavailable, proceeding with deployment"
            echo "approved=true" >> "$GITHUB_OUTPUT"
            echo "estimated-cost=unknown" >> "$GITHUB_OUTPUT"
          else
            echo "📊 Cost analysis: \$$ESTIMATED_COST/month"
            COST_INT=$(echo "$ESTIMATED_COST" | cut -d'.' -f1)

            if [ "$COST_INT" -gt 25 ]; then
              echo "❌ COST GATE FAILED: \$$ESTIMATED_COST exceeds \$25/month"
              echo "approved=false" >> "$GITHUB_OUTPUT"
              exit 1
            else
              echo "✅ COST GATE PASSED: \$$ESTIMATED_COST within budget"
              echo "approved=true" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Upload Cost Analysis Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cost-analysis-results
          path: cost-analysis/
          retention-days: 7

  # Stage 3: Comprehensive Testing Suite
  unit-and-function-tests:
    if: >
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
      (github.event.inputs.skip_tests != 'true') &&
      (needs.changes.outputs.functions == 'true' || needs.changes.outputs.tests == 'true')
    runs-on: ubuntu-latest
    name: Unit and Function Tests
    needs: changes
    strategy:
      matrix:
        test-type: [unit, function]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r functions/requirements.txt
          pip install pytest pytest-cov pytest-html pytest-xdist requests

      - name: Run ${{ matrix.test-type }} tests
        run: |
          python -m pytest -m "${{ matrix.test-type }}" \
            --tb=short \
            --maxfail=3 \
            --cov=functions \
            --cov-report=xml \
            --cov-report=term-missing \
            --junitxml=test-results-${{ matrix.test-type }}.xml \
            -v

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test-type }}
          path: |
            test-results-${{ matrix.test-type }}.xml
            coverage.xml

      - name: Upload coverage to Codecov
        if: matrix.test-type == 'unit'
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella

  # Stage 4a: Build and Package Functions (before infrastructure)
  build-functions:
    if: needs.changes.outputs.infrastructure == 'true' || needs.changes.outputs.functions == 'true'
    needs: [changes, unit-and-function-tests, cost-gate, security-gate, workflow-lint]
    runs-on: ubuntu-latest
    outputs:
      package-name: ${{ steps.version.outputs.package-name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate Package Version
        id: version
        run: |
          VERSION="$(date +%Y%m%d%H%M%S)-$(git rev-parse --short HEAD)"
          PACKAGE_NAME="function-app-$VERSION.zip"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "package-name=$PACKAGE_NAME" >> "$GITHUB_OUTPUT"
          echo "Generated package version: $VERSION"

      - name: Create Function Package
        run: |
          cd functions/
          # Create deployment package for Python Azure Functions
          zip -r "../${{ steps.version.outputs.package-name }}" . -x "*.pyc" "*/__pycache__/*" ".python_packages/*"
          echo "Created package: ${{ steps.version.outputs.package-name }}"

      - name: Upload Package as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: function-package
          path: ${{ steps.version.outputs.package-name }}
          retention-days: 30

  # Stage 4b: Deploy Infrastructure with Function Package URL
  deploy-to-staging:
    if: >
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
      (needs.changes.outputs.infrastructure == 'true' || needs.changes.outputs.functions == 'true') &&
      (needs.security-gate.result == 'success' || needs.security-gate.result == 'skipped') &&
      (needs.cost-gate.result == 'success' || needs.cost-gate.result == 'skipped') &&
      (needs.unit-and-function-tests.result == 'success' || needs.unit-and-function-tests.result == 'skipped')
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Staging
    needs: [changes, security-gate, cost-gate, unit-and-function-tests, build-functions]
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Restore Terraform Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/application/.terraform
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('infra/application/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-providers-${{ runner.os }}-

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Download Function Package
        uses: actions/download-artifact@v4
        with:
          name: function-package
          path: ./

      - name: Deploy Infrastructure
        run: |
          cd infra/application

          # Use cached providers for faster init
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          mkdir -p $TF_PLUGIN_CACHE_DIR

          # Fast terraform init (providers cached)
          terraform init -backend-config=backend-staging.hcl

          # Deploy infrastructure first (without function package URL for now)
          terraform apply -auto-approve \
            -var-file="staging.tfvars"

          # Get outputs for function deployment
          FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
          RESOURCE_GROUP=$(terraform output -raw resource_group_name)
          KEY_VAULT_NAME=$(terraform output -raw key_vault_name)
          STORAGE_ACCOUNT=$(terraform output -raw storage_account_name)

          {
            echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME"
            echo "RESOURCE_GROUP=$RESOURCE_GROUP"
            echo "KEY_VAULT_NAME=$KEY_VAULT_NAME"
            echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT"
          } >> "$GITHUB_ENV"

      - name: Deploy Function Package
        run: |
          # Deploy function using the traditional method
          echo "Deploying function package: ${{ needs.build-functions.outputs.package-name }}"
          az functionapp deployment source config-zip \
            --resource-group "$RESOURCE_GROUP" \
            --name "$FUNCTION_APP_NAME" \
            --src "${{ needs.build-functions.outputs.package-name }}"

          echo "Function app deployment completed"

      - name: Wire SummaryWomble key to app setting
        run: |
          # Use IaC-managed secret from Key Vault as the SummaryWomble function key
          echo "Retrieving SummaryWomble function key from Key Vault ($KEY_VAULT_NAME)..."
          SECRET=$(az keyvault secret show \
            --vault-name "$KEY_VAULT_NAME" \
            --name summarywomble-function-key \
            --query value -o tsv)

          if [ -z "$SECRET" ] || [ "$SECRET" = "null" ]; then
            echo "Missing Key Vault secret 'summarywomble-function-key'" && exit 1
          fi

          # Optimized wait for function registration (reduced from 20 attempts)
          echo "Waiting for SummaryWomble to register..."
          for i in {1..10}; do
            if az functionapp function show \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble 1>/dev/null 2>&1; then
              echo "Function 'SummaryWomble' is present"
              break
            fi
            echo "Attempt $i/10: function not found yet; sleeping 8s..."
            sleep 8
          done

          # Fast retry for function key setting (reduced retries)
          echo "Setting SummaryWomble function key"
          for i in {1..3}; do
            if az functionapp function keys set \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble \
              --key-name internal \
              --key-value "$SECRET" 1>/dev/null; then
              echo "Function key set successfully"
              break
            fi
            echo "Key set failed (attempt $i/3). Waiting 5s..."
            sleep 5
          done

          # Restart to ensure settings are applied
          az functionapp restart --name "$FUNCTION_APP_NAME" --resource-group "$RESOURCE_GROUP"

  # Stage 5: Integration Tests (after staging deployment)
  run-integration-tests:
    if: >
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
      (github.event.inputs.skip_tests != 'true') &&
      (needs.changes.outputs.functions == 'true' || needs.changes.outputs.tests == 'true')
    runs-on: ubuntu-latest
    name: Run Integration Tests
    needs: [changes, deploy-to-staging]
    environment:
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform (Cached)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r functions/requirements.txt
          pip install pytest pytest-cov requests azure-identity azure-keyvault-secrets

      - name: Run integration tests
        env:
          FUNCTION_URL: ${{ secrets.FUNCTION_APP_URL }}
          AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
        run: |
          # Get function app URL from terraform outputs if not in secrets
          if [ -z "$FUNCTION_URL" ]; then
            cd infra/application
            export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
            terraform init -backend-config=backend-staging.hcl
            FUNCTION_URL=$(terraform output -raw function_app_url)
            FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
            cd ../..
            echo "Testing function app: $FUNCTION_APP_NAME"
            echo "Function URL: $FUNCTION_URL"
          fi

          # Optimized readiness check
          echo "Checking function app readiness..."
          READY=false
          for i in {1..10}; do
            echo "Attempt $i/10: Checking function app..."
            if curl -s --max-time 10 "$FUNCTION_URL" > /dev/null; then
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$FUNCTION_URL/api/SummaryWomble" || echo "000")
              if [ "$STATUS" = "401" ] || [ "$STATUS" = "400" ]; then
                echo "✅ Function app ready (SummaryWomble: $STATUS)"
                READY=true
                break
              elif [ "$STATUS" = "404" ]; then
                echo "⏳ SummaryWomble not registered yet ($STATUS)"
              else
                echo "⚠️  Unexpected status: $STATUS"
              fi
            else
              echo "⏳ Function app not responding"
            fi
            sleep 10
          done

          if [ "$READY" = "false" ]; then
            echo "⚠️  Function app not ready within timeout, running tests anyway"
          fi

          # Run integration tests
          export FUNCTION_URL=$FUNCTION_URL
          export FUNCTION_APP_NAME=$FUNCTION_APP_NAME
          python -m pytest -m "integration" \
            --tb=short \
            --maxfail=1 \
            --junitxml=test-results-integration.xml \
            -v

      - name: Upload integration test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-integration
          path: test-results-integration.xml

  # Test Results Summary and Reporting
  test-report:
    runs-on: ubuntu-latest
    needs: [unit-and-function-tests, run-integration-tests]
    if: always()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all test artifacts
        uses: actions/download-artifact@v4
        with:
          path: test-artifacts

      - name: Generate test summary
        run: |
          {
            echo "# Test Results Summary"
            echo ""

            # Count test files
            unit_files=$(find test-artifacts -name "*unit*" -type f | wc -l)
            function_files=$(find test-artifacts -name "*function*" -type f | wc -l)
            integration_files=$(find test-artifacts -name "*integration*" -type f | wc -l)

            echo "## Test Execution"
            echo "- Unit Tests: ${unit_files} artifact(s)"
            echo "- Function Tests: ${function_files} artifact(s)"
            echo "- Integration Tests: ${integration_files} artifact(s)"
            echo ""

            # Check for failures
            if [ "${{ needs.unit-and-function-tests.result }}" != "success" ]; then
              echo "❌ Unit/Function tests failed"
            else
              echo "✅ Unit/Function tests passed"
            fi

            if [ "${{ needs.run-integration-tests.result }}" != "success" ] && [ "${{ needs.run-integration-tests.result }}" != "skipped" ]; then
              echo "❌ Integration tests failed"
            elif [ "${{ needs.run-integration-tests.result }}" == "success" ]; then
              echo "✅ Integration tests passed"
            else
              echo "⏭️ Integration tests skipped"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Read test results and create comment
            let comment = '## 🧪 Test Results\n\n';

            if ('${{ needs.unit-and-function-tests.result }}' === 'success') {
              comment += '✅ Unit and Function tests passed\n';
            } else {
              comment += '❌ Unit and Function tests failed\n';
            }

            if ('${{ needs.run-integration-tests.result }}' === 'success') {
              comment += '✅ Integration tests passed\n';
            } else if ('${{ needs.run-integration-tests.result }}' === 'skipped') {
              comment += '⏭️ Integration tests skipped (PR only)\n';
            } else {
              comment += '❌ Integration tests failed\n';
            }

            comment += '\n[View detailed results in Actions](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Stage 6a: Build Functions for Production
  build-functions-production:
    if: >
      github.ref == 'refs/heads/main' &&
      ((github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')) &&
      needs.changes.outputs.functions == 'true'
    runs-on: ubuntu-latest
    name: Build and Upload Function Package for Production
    needs: [changes, security-gate, cost-gate, unit-and-function-tests, run-integration-tests]
    environment: production
    outputs:
      package-url: ${{ steps.upload.outputs.package-url }}
      package-version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Generate Package Version
        id: version
        run: |
          VERSION="$(date +%Y%m%d%H%M%S)-$(git rev-parse --short HEAD)"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Generated package version: $VERSION"

      - name: Create Function Package
        run: |
          cd functions
          # Create deployment package for Python Azure Functions
          zip -r ../function-app-${{ steps.version.outputs.version }}.zip . \
            -x "*.pyc" "*/__pycache__/*" ".python_packages/*" "tests/*"
          echo "Function package created: function-app-${{ steps.version.outputs.version }}.zip"

      - name: Upload Package to Storage
        id: upload
        run: |
          # Upload to function-releases container (production storage account)
          STORAGE_ACCOUNT="$(az storage account list --resource-group "ai-content-production-rg" --query "[0].name" -o tsv)"

          az storage blob upload \
            --account-name "$STORAGE_ACCOUNT" \
            --container-name "topics" \
            --name "function-app-${{ steps.version.outputs.version }}.zip" \
            --file "function-app-${{ steps.version.outputs.version }}.zip" \
            --auth-mode login \
            --overwrite

          # Generate SAS URL with long expiration for Terraform
          PACKAGE_URL="$(az storage blob generate-sas \
            --account-name "$STORAGE_ACCOUNT" \
            --container-name "topics" \
            --name "function-app-${{ steps.version.outputs.version }}.zip" \
            --permissions r \
            --expiry "$(date -d "+1 year" --iso-8601)" \
            --full-uri \
            --auth-mode login)"

          echo "package-url=$PACKAGE_URL" >> "$GITHUB_OUTPUT"
          echo "Package uploaded and SAS URL generated"

  # Stage 6b: Deploy to Production (main branch only, after all validations)
  deploy-to-production:
    if: >
      github.ref == 'refs/heads/main' &&
      ((github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')) &&
      (needs.changes.outputs.infrastructure == 'true' || needs.changes.outputs.functions == 'true')
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Production
    needs: [changes, security-gate, cost-gate, unit-and-function-tests, run-integration-tests, build-functions-production]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Restore Terraform Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/application/.terraform
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('infra/application/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-providers-${{ runner.os }}-

      - name: Deploy to Production
        run: |
          cd infra/application

          # Use cached providers for faster init
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          mkdir -p $TF_PLUGIN_CACHE_DIR

          # Configure backend for remote state
          terraform init -backend-config=backend-production.hcl

          # Deploy infrastructure with function package URL
          terraform apply -auto-approve \
            -var-file="production.tfvars" \
            -var="function_package_url=${{ needs.build-functions-production.outputs.package-url }}"

          # Get outputs for any remaining tasks
          FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
          RESOURCE_GROUP=$(terraform output -raw resource_group_name)

          {
            echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME"
            echo "RESOURCE_GROUP=$RESOURCE_GROUP"
          } >> "$GITHUB_ENV"

      - name: Wire SummaryWomble key to app setting (production)
        run: |
          echo "Retrieving SummaryWomble function key from Key Vault (production)..."
          # Get KEY_VAULT_NAME from terraform output (cached)
          cd infra/application
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          terraform init -backend-config=backend-production.hcl
          KEY_VAULT_NAME=$(terraform output -raw key_vault_name)
          cd ../..

          SECRET=$(az keyvault secret show \
            --vault-name "$KEY_VAULT_NAME" \
            --name summarywomble-function-key \
            --query value -o tsv)

          if [ -z "$SECRET" ] || [ "$SECRET" = "null" ]; then
            echo "Missing Key Vault secret 'summarywomble-function-key' (production)" && exit 1
          fi

          # Optimized wait (reduced from 20 attempts)
          echo "Waiting for SummaryWomble to register (production)..."
          for i in {1..10}; do
            if az functionapp function show \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble 1>/dev/null 2>&1; then
              echo "Function 'SummaryWomble' is present"
              break
            fi
            echo "Attempt $i/10: function not found yet; sleeping 8s..."
            sleep 8
          done

          # Fast retry (reduced retries)
          echo "Setting SummaryWomble function key (production)"
          for i in {1..3}; do
            if az functionapp function keys set \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble \
              --key-name internal \
              --key-value "$SECRET" 1>/dev/null; then
              echo "Function key set successfully"
              break
            fi
            echo "Key set failed (attempt $i/3). Waiting 5s..."
            sleep 5
          done

          az functionapp restart --name "$FUNCTION_APP_NAME" --resource-group "$RESOURCE_GROUP"

  # Stage 7: Deployment Summary
  deployment-notification:
    runs-on: ubuntu-latest
    name: Pipeline Summary
    needs: [changes, deploy-to-staging, deploy-to-production, test-report]
    if: always()

    steps:
      - name: Pipeline Summary
        run: |
          echo "## 🚀 Pipeline Execution Summary"
          echo "**Changed Components:**"
          echo "- Infrastructure: ${{ needs.changes.outputs.infrastructure }}"
          echo "- Functions: ${{ needs.changes.outputs.functions }}"
          echo "- Tests: ${{ needs.changes.outputs.tests }}"
          echo "- Docs: ${{ needs.changes.outputs.docs }}"
          echo ""

          # Test Results Summary
          echo "**Test Results:**"
          if [ "${{ needs.test-report.result }}" == "success" ]; then
            echo "✅ All tests completed successfully"
          elif [ "${{ needs.test-report.result }}" == "skipped" ]; then
            echo "⏭️ Tests skipped (no function/test changes)"
          else
            echo "❌ Test failures detected"
          fi
          echo ""

          # Deployment Results
          if [ "${{ needs.deploy-to-staging.result }}" == "success" ]; then
            echo "✅ Staging deployment completed successfully"
          elif [ "${{ needs.deploy-to-staging.result }}" == "skipped" ]; then
            echo "⏭️ Staging deployment skipped (no infrastructure/function changes)"
          fi

          if [ "${{ needs.deploy-to-production.result }}" == "success" ]; then
            echo "✅ Production deployment completed successfully"
          elif [ "${{ needs.deploy-to-production.result }}" == "skipped" ]; then
            echo "⏭️ Production deployment skipped (not main branch or no changes)"
          fi

          if [ "${{ needs.deploy-to-staging.result }}" == "failure" ] || [ "${{ needs.deploy-to-production.result }}" == "failure" ]; then
            echo "❌ Deployment failed - check logs for details"
            exit 1
          fi
