name: Consolidated CI/CD Pipeline

on:
  push:
    branches: [ develop, main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_security:
        description: 'Skip security ch    - name: Run Integration Tests
      run: |
        # Install test dependencies
        pip install pytest requests azure-identity azure-keyvault-secrets
        
        # Get function app URL
        cd infra/application
        terraform init -backend-config="storage_account_name=${{ vars.TERRAFORM_STATE_STORAGE_ACCOUNT }}" 
                      -backend-config="container_name=tfstate" 
                      -backend-config="key=${{ github.event.inputs.environment || 'staging' }}.tfstate" 
                      -backend-config="resource_group_name=ai-content-farm-bootstrap"
        FUNCTION_URL=$(terraform output -raw function_app_url)
        cd ../..
        
        # Run tests
        export FUNCTION_URL=$FUNCTION_URL
        python -m pytest tests/integration/ -vution)'
        required: false
        default: false
        type: boolean
      skip_cost:
        description: 'Skip cost checks (when Infracost unavailable)'
        required: false
        default: false
        type: boolean

# OIDC permissions for Azure authentication
permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

env:
  AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}

jobs:
  # Stage 1: Security and Compliance Validation
  security-gate:
    runs-on: ubuntu-latest
    name: Security and Compliance Validation
    outputs:
      security-approved: ${{ steps.security-gate.outputs.approved }}
      critical-findings: ${{ steps.security-gate.outputs.critical-findings }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install Security Tools
      run: |
        pip3 install checkov
        # Install tfsec with fallback
        wget -O tfsec https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64 && chmod +x tfsec && sudo mv tfsec /usr/local/bin || echo "tfsec installation failed, continuing without it"
        LATEST_URL=$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E "https://.*Linux_x86_64.tar.gz" | head -1)
        curl -L "$LATEST_URL" > terrascan.tar.gz
        tar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz
        sudo mv terrascan /usr/local/bin
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin

    - name: Run Security Scans
      id: security-scans
      run: |
        echo "Running comprehensive security scans..."
        
        # Run Checkov
        checkov -d infra --quiet --compact --output json --output-file-path security-results/checkov.json || CHECKOV_EXIT=$?
        checkov -d functions --quiet --compact --output json --output-file-path security-results/checkov-functions.json || true
        
        # Run TFSec
        cd infra/application && tfsec . --format json --out ../../security-results/tfsec.json --soft-fail || TFSEC_EXIT=$?
        cd ../..
        
        # Run Terrascan
        cd infra/application && terrascan scan -i terraform --output json > ../../security-results/terrascan.json || TERRASCAN_EXIT=$?
        cd ../..
        
        # Generate SBOM
        syft functions -o json=security-results/sbom.json
        
        echo "Security scans completed"
      continue-on-error: true

    - name: Security Gate Decision
      id: security-gate
      run: |
        mkdir -p security-results
        
        # Analyze security scan results
        CRITICAL_COUNT=0
        HIGH_COUNT=0
        
        # Check Checkov results for critical/high findings
        if [ -f security-results/checkov.json ]; then
          CRITICAL_COUNT=$(jq '.results.failed_checks | map(select(.severity == "CRITICAL")) | length' security-results/checkov.json 2>/dev/null || echo 0)
          HIGH_COUNT=$(jq '.results.failed_checks | map(select(.severity == "HIGH")) | length' security-results/checkov.json 2>/dev/null || echo 0)
        fi
        
        echo "Critical findings: $CRITICAL_COUNT"
        echo "High findings: $HIGH_COUNT"
        echo "critical-findings=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
        
        # Simplified security gate logic - pass or fail
        if [ "$CRITICAL_COUNT" -gt 0 ]; then
          echo "‚ùå SECURITY GATE FAILED: $CRITICAL_COUNT critical security findings detected"
          echo "approved=false" >> $GITHUB_OUTPUT
          exit 1
        elif [ "$HIGH_COUNT" -gt 10 ]; then
          echo "‚ùå SECURITY GATE FAILED: $HIGH_COUNT high-severity findings exceed limit (>10)"
          echo "approved=false" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "‚úÖ SECURITY GATE PASSED: No critical findings, $HIGH_COUNT high findings"
          echo "approved=true" >> $GITHUB_OUTPUT
        fi

    - name: Upload Security Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: security-results/
        retention-days: 30

  # Stage 2: Cost Impact Analysis
  cost-gate:
    runs-on: ubuntu-latest
    name: Cost Impact and Budget Approval
    needs: security-gate
    if: needs.security-gate.outputs.security-approved != 'false'
    outputs:
      cost-approved: ${{ steps.cost-gate.outputs.approved }}
      estimated-cost: ${{ steps.cost-gate.outputs.estimated-cost }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2

    - name: Install Infracost for Better Cost Estimation
      run: |
        # Install Infracost for accurate Azure cost estimation
        curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh
        
        # Verify installation
        infracost --version
        
        # Get Infracost API key from CI/CD Key Vault (in bootstrap resource group)
        echo "üîë Retrieving Infracost API key from CI/CD Key Vault..."
        
        # First, verify Azure authentication
        echo "üîç Verifying Azure authentication..."
        if ! az account show > /dev/null 2>&1; then
          echo "‚ùå Azure authentication failed. Please check OIDC configuration."
          exit 1
        fi
        
        # Look for CI/CD Key Vault in bootstrap resource group
        BOOTSTRAP_RG="ai-content-farm-bootstrap"
        echo "üîç Looking for CI/CD Key Vault in bootstrap resource group: $BOOTSTRAP_RG"
        
        if az group show --name "$BOOTSTRAP_RG" > /dev/null 2>&1; then
          echo "‚úÖ Found bootstrap resource group: $BOOTSTRAP_RG"
          # Find CI/CD Key Vault (should contain 'cicd' in name)
          KEYVAULT_NAME=$(az keyvault list --resource-group "$BOOTSTRAP_RG" --query "[?contains(name, 'cicd')].name" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$KEYVAULT_NAME" ]; then
            echo "‚úÖ Found CI/CD Key Vault: $KEYVAULT_NAME"
            
            # Check if we have permission to access the Key Vault
            if ! az keyvault secret list --vault-name "$KEYVAULT_NAME" > /dev/null 2>&1; then
              echo "‚ùå No permission to access CI/CD Key Vault. This indicates missing access policy."
              echo "The GitHub Actions service principal needs Key Vault access policy with 'Get' and 'List' permissions."
              echo "Please deploy the bootstrap infrastructure first, then re-run this pipeline."
              echo "Using Infracost free tier for now."
              infracost configure set api_key ico-free-tier-key || echo "Using free tier"
            else
              # Try to get the API key from CI/CD vault
              INFRACOST_API_KEY=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "infracost-api-key" --query "value" -o tsv 2>/dev/null || echo "")
              if [ -n "$INFRACOST_API_KEY" ] && [ "$INFRACOST_API_KEY" != "placeholder-get-from-infracost-io" ]; then
                echo "‚úÖ Using Infracost API key from CI/CD Key Vault"
                infracost configure set api_key "$INFRACOST_API_KEY"
              else
                echo "‚ö†Ô∏è  Infracost API key not found or is placeholder, using free tier"
                infracost configure set api_key ico-free-tier-key || echo "Using free tier"
              fi
            fi
          else
            echo "‚ö†Ô∏è  CI/CD Key Vault not found. This might be a first-time deployment."
            echo "Using Infracost free tier for cost estimation."
            infracost configure set api_key ico-free-tier-key || echo "Using free tier"
          fi
        else
          echo "‚ö†Ô∏è  Bootstrap resource group not found. This might be a first-time deployment."
          echo "Using Infracost free tier for cost estimation."
          infracost configure set api_key ico-free-tier-key || echo "Using free tier"
        fi

    - name: Terraform Plan for Cost Analysis
      id: terraform-plan
      run: |
        cd infra/application
        
        # Configure backend for remote state
        terraform init -backend-config="storage_account_name=${{ vars.TERRAFORM_STATE_STORAGE_ACCOUNT }}" \
                      -backend-config="container_name=tfstate" \
                      -backend-config="key=${{ github.event.inputs.environment || 'staging' }}.tfstate" \
                      -backend-config="resource_group_name=ai-content-farm-bootstrap"
        
        # Create terraform plan with better error handling
        echo "üîß Creating Terraform plan..."
        if terraform plan -out=tfplan -var="environment=${{ github.event.inputs.environment || 'staging' }}" 2>&1 | tee plan.log; then
          echo "‚úÖ Terraform plan successful"
          PLAN_SUCCESS=true
        else
          echo "‚ö†Ô∏è  Terraform plan had issues, checking if they're permission-related..."
          PLAN_SUCCESS=false
          
          # Check if errors are related to Key Vault permissions
          if grep -q "does not have secrets get permission" plan.log; then
            echo "üîç Detected Key Vault permission errors - this is expected on first deployment"
            echo "The GitHub Actions service principal needs access policy, which will be created by this deployment"
            echo "Proceeding with deployment to establish proper permissions..."
            PLAN_SUCCESS=true
          elif grep -q "Authorization_RequestDenied" plan.log; then
            echo "üîç Detected Azure AD permission errors - this might be expected for service principal lookups"
            echo "Proceeding with deployment..."
            PLAN_SUCCESS=true
          fi
        fi
        
        if [ "$PLAN_SUCCESS" = "false" ]; then
          echo "‚ùå Terraform plan failed with non-permission errors"
          cat plan.log
          exit 1
        fi
        
        # Only use Infracost for accurate cost estimation if terraform plan succeeded cleanly
        if command -v infracost &> /dev/null; then
          echo "Using Infracost for accurate cost estimation..."
          mkdir -p ../cost-analysis
          
          # Try to get Infracost breakdown with usage file
          if infracost breakdown --path tfplan --usage-file infracost-usage.yml --format json > ../cost-analysis/infracost.json 2>&1; then
            ESTIMATED_COST=$(jq -r '.totalMonthlyCost' ../cost-analysis/infracost.json 2>/dev/null || echo "unavailable")
            
            if [ "$ESTIMATED_COST" != "null" ] && [ "$ESTIMATED_COST" != "unavailable" ] && [ "$ESTIMATED_COST" != "0" ]; then
              echo "‚úÖ Infracost estimation successful with usage data: \$$ESTIMATED_COST/month"
              echo "estimated-cost=$ESTIMATED_COST" >> $GITHUB_OUTPUT
              echo "cost-available=true" >> $GITHUB_OUTPUT
              
              # Show cost breakdown for transparency
              echo "üìä Cost breakdown by service:"
              jq -r '.projects[0].breakdown.resources[] | "\(.name): $\(.monthlyCost // 0)"' ../cost-analysis/infracost.json | head -10
            else
              echo "‚ö†Ô∏è  Infracost returned invalid cost data"
              echo "estimated-cost=unavailable" >> $GITHUB_OUTPUT
              echo "cost-available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Infracost breakdown failed"
            cat ../cost-analysis/infracost.json 2>/dev/null || echo "No error output available"
            echo "estimated-cost=unavailable" >> $GITHUB_OUTPUT
            echo "cost-available=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå Infracost not available"
          echo "estimated-cost=unavailable" >> $GITHUB_OUTPUT
          echo "cost-available=false" >> $GITHUB_OUTPUT
        fi

    - name: Cost Gate Decision
      id: cost-gate
      run: |
        mkdir -p cost-analysis
        ESTIMATED_COST="${{ steps.terraform-plan.outputs.estimated-cost }}"
        COST_AVAILABLE="${{ steps.terraform-plan.outputs.cost-available }}"
        
        # Simplified cost gate - if we can't get costs, assume it's reasonable for development
        if [ "$COST_AVAILABLE" == "false" ] || [ "$ESTIMATED_COST" == "unavailable" ]; then
          echo "‚ö†Ô∏è  Cost estimation unavailable, proceeding with deployment"
          echo "approved=true" >> $GITHUB_OUTPUT
          echo "estimated-cost=unknown" >> $GITHUB_OUTPUT
        else
          echo "üìä Cost analysis successful: \$$ESTIMATED_COST/month"
          
          # Convert to integer for comparison (remove decimal if present)
          COST_INT=$(echo "$ESTIMATED_COST" | cut -d'.' -f1)
          
          # Simplified cost thresholds - fail only if very expensive
          if [ "$COST_INT" -gt 25 ]; then
            echo "‚ùå COST GATE FAILED: Estimated cost \$$ESTIMATED_COST exceeds \$25/month limit"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ COST GATE PASSED: Estimated cost \$$ESTIMATED_COST within budget"
            echo "approved=true" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Upload Cost Analysis Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cost-analysis-results
        path: |
          cost-analysis/
          infra/infracost-usage.yml
        retention-days: 30

  # Stage 3: Deploy to Staging
  deploy-to-staging:
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Staging
    needs: [security-gate, cost-gate]
    if: |
      needs.security-gate.outputs.security-approved == 'true' &&
      needs.cost-gate.outputs.cost-approved == 'true' &&
      github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy Infrastructure
      run: |
        cd infra/application
        
        # Configure backend for remote state
        terraform init -backend-config="storage_account_name=${{ vars.TERRAFORM_STATE_STORAGE_ACCOUNT }}" \
                      -backend-config="container_name=tfstate" \
                      -backend-config="key=${{ github.event.inputs.environment || 'staging' }}.tfstate" \
                      -backend-config="resource_group_name=ai-content-farm-bootstrap"
        
        terraform apply -auto-approve -var="environment=${{ github.event.inputs.environment || 'staging' }}"
        
        # Get outputs for function deployment
        FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
        RESOURCE_GROUP=$(terraform output -raw resource_group_name)
        
        echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME" >> $GITHUB_ENV
        echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

    - name: Deploy Python Function App
      run: |
        cd functions
        
        # Create deployment package for Python Azure Functions
        # Azure Functions expects the function files directly, not in a venv
        zip -r ../function-app.zip . -x "*.pyc" "*/__pycache__/*" ".python_packages/*"
        
        # Deploy using Azure CLI (works reliably for Python functions)
        az functionapp deployment source config-zip \
          --resource-group $RESOURCE_GROUP \
          --name $FUNCTION_APP_NAME \
          --src ../function-app.zip

  # Stage 4: Integration Tests
  run-integration-tests:
    runs-on: ubuntu-latest
    name: Run End-to-End Integration Tests
    needs: deploy-to-staging
    if: needs.deploy-to-staging.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Run Integration Tests
      run: |
        # Install test dependencies
        pip install pytest requests azure-identity azure-keyvault-secrets
        
        # Get function app URL from terraform outputs
        cd infra/application
        terraform init -backend-config="storage_account_name=${{ vars.TERRAFORM_STATE_STORAGE_ACCOUNT }}" \
                      -backend-config="container_name=tfstate" \
                      -backend-config="key=${{ github.event.inputs.environment || 'staging' }}.tfstate" \
                      -backend-config="resource_group_name=ai-content-farm-bootstrap"
        
        # Get the function app URL
        FUNCTION_URL=$(terraform output -raw function_app_url)
        FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
        cd ../..
        
        echo "Testing function app: $FUNCTION_APP_NAME"
        echo "Function URL: $FUNCTION_URL"
        
        # Wait for deployment to be ready
        echo "Waiting for function app to be ready..."
        for i in {1..30}; do
          if curl -s "$FUNCTION_URL" > /dev/null; then
            echo "Function app is responding"
            break
          fi
          echo "Attempt $i/30: Function app not ready yet, waiting 10 seconds..."
          sleep 10
        done
        
        # Run tests with environment variables
        export FUNCTION_URL=$FUNCTION_URL
        export FUNCTION_APP_NAME=$FUNCTION_APP_NAME
        python -m pytest tests/integration/ -v --tb=short

  # Stage 5: Deploy to Production (main branch only)
  deploy-to-production:
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Production
    needs: [security-gate, cost-gate, run-integration-tests]
    if: |
      always() && 
      needs.run-integration-tests.result == 'success' &&
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy to Production
      run: |
        cd infra/application
        
        # Configure backend for remote state
        terraform init -backend-config="storage_account_name=${{ vars.TERRAFORM_STATE_STORAGE_ACCOUNT }}" \
                      -backend-config="container_name=tfstate" \
                      -backend-config="key=production.tfstate" \
                      -backend-config="resource_group_name=ai-content-farm-bootstrap"
        
        terraform apply -auto-approve -var="environment=production"
        
        # Get outputs for function deployment
        FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
        RESOURCE_GROUP=$(terraform output -raw resource_group_name)
        
        echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME" >> $GITHUB_ENV
        echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

    - name: Deploy Python Function App to Production
      run: |
        cd functions
        
        # Create deployment package for Python Azure Functions
        zip -r ../function-app-prod.zip . -x "*.pyc" "*/__pycache__/*" ".python_packages/*"
        
        # Deploy using Azure CLI
        az functionapp deployment source config-zip \
          --resource-group $RESOURCE_GROUP \
          --name $FUNCTION_APP_NAME \
          --src ../function-app-prod.zip

  # Stage 6: Notification
  deployment-notification:
    runs-on: ubuntu-latest
    name: Deployment Status Notification
    needs: [deploy-to-staging, deploy-to-production]
    if: always()
    
    steps:
    - name: Notify Deployment Status
      run: |
        if [ "${{ needs.deploy-to-staging.result }}" == "success" ]; then
          echo "‚úÖ Staging deployment completed successfully"
        fi
        if [ "${{ needs.deploy-to-production.result }}" == "success" ]; then
          echo "‚úÖ Production deployment completed successfully"
        fi
        if [ "${{ needs.deploy-to-staging.result }}" == "failure" ] || [ "${{ needs.deploy-to-production.result }}" == "failure" ]; then
          echo "‚ùå Deployment failed - check logs for details"
        fi
