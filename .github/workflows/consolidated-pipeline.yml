name: Consolidated CI/CD Pipeline

on:
  push:
    branches: [ develop, main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_security:
        description: 'Skip security checks (use with caution)'
        required: false
        default: false
        type: boolean
      skip_cost:
        description: 'Skip cost checks (when Infracost unavailable)'
        required: false
        default: false
        type: boolean

# OIDC permissions for Azure authentication
permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

env:
  AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}

jobs:
  # Stage 1: Security and Compliance Validation
  security-gate:
    runs-on: ubuntu-latest
    name: Security and Compliance Validation
    outputs:
      security-approved: ${{ steps.security-gate.outputs.approved }}
      critical-findings: ${{ steps.security-gate.outputs.critical-findings }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install Security Tools
      run: |
        pip3 install checkov
        curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
        LATEST_URL=$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E "https://.*Linux_x86_64.tar.gz" | head -1)
        curl -L "$LATEST_URL" > terrascan.tar.gz
        tar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz
        sudo mv terrascan /usr/local/bin
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin

    - name: Run Security Scans
      id: security-scans
      run: |
        echo "Running comprehensive security scans..."
        
        # Run Checkov
        checkov -d infra --quiet --compact --output json --output-file-path security-results/checkov.json || CHECKOV_EXIT=$?
        checkov -d functions --quiet --compact --output json --output-file-path security-results/checkov-functions.json || true
        
        # Run TFSec
        cd infra && tfsec . --format json --out ../security-results/tfsec.json --soft-fail || TFSEC_EXIT=$?
        cd ..
        
        # Run Terrascan
        cd infra && terrascan scan -i terraform --output json > ../security-results/terrascan.json || TERRASCAN_EXIT=$?
        cd ..
        
        # Generate SBOM
        syft functions -o json=security-results/sbom.json
        
        echo "Security scans completed"
      continue-on-error: true

    - name: Security Gate Decision
      id: security-gate
      run: |
        mkdir -p security-results
        
        # Analyze security scan results
        CRITICAL_COUNT=0
        HIGH_COUNT=0
        
        # Check Checkov results for critical/high findings
        if [ -f security-results/checkov.json ]; then
          CRITICAL_COUNT=$(jq '.results.failed_checks | map(select(.severity == "CRITICAL")) | length' security-results/checkov.json 2>/dev/null || echo 0)
          HIGH_COUNT=$(jq '.results.failed_checks | map(select(.severity == "HIGH")) | length' security-results/checkov.json 2>/dev/null || echo 0)
        fi
        
        echo "Critical findings: $CRITICAL_COUNT"
        echo "High findings: $HIGH_COUNT"
        echo "critical-findings=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
        
        # Simplified security gate logic - pass or fail
        if [ "$CRITICAL_COUNT" -gt 0 ]; then
          echo "❌ SECURITY GATE FAILED: $CRITICAL_COUNT critical security findings detected"
          echo "approved=false" >> $GITHUB_OUTPUT
          exit 1
        elif [ "$HIGH_COUNT" -gt 10 ]; then
          echo "❌ SECURITY GATE FAILED: $HIGH_COUNT high-severity findings exceed limit (>10)"
          echo "approved=false" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "✅ SECURITY GATE PASSED: No critical findings, $HIGH_COUNT high findings"
          echo "approved=true" >> $GITHUB_OUTPUT
        fi

    - name: Upload Security Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: security-results/
        retention-days: 30

  # Stage 2: Cost Impact Analysis
  cost-gate:
    runs-on: ubuntu-latest
    name: Cost Impact and Budget Approval
    needs: security-validation
    if: needs.security-validation.outputs.security-approved != 'false'
    outputs:
      cost-approved: ${{ steps.cost-gate.outputs.approved }}
      estimated-cost: ${{ steps.cost-gate.outputs.estimated-cost }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2

    - name: Install Infracost for Better Cost Estimation
      run: |
        # Install Infracost for accurate Azure cost estimation
        curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh
        
        # Verify installation
        infracost --version
        
        # Get Infracost API key from Azure Key Vault
        echo "🔑 Retrieving Infracost API key from Azure Key Vault..."
        KEYVAULT_NAME=$(az keyvault list --resource-group "ai-content-dev-rg" --query "[0].name" -o tsv 2>/dev/null || echo "")
        if [ -n "$KEYVAULT_NAME" ]; then
          INFRACOST_API_KEY=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "infracost-api-key" --query "value" -o tsv 2>/dev/null || echo "")
          if [ -n "$INFRACOST_API_KEY" ] && [ "$INFRACOST_API_KEY" != "placeholder-get-from-infracost-io" ]; then
            echo "✅ Using Infracost API key from Key Vault"
            infracost configure set api_key "$INFRACOST_API_KEY"
          else
            echo "⚠️  Infracost API key not found in Key Vault, using free tier"
            infracost configure set api_key ico-free-tier-key || echo "Using free tier"
          fi
        else
          echo "⚠️  Key Vault not found, using free tier"
          infracost configure set api_key ico-free-tier-key || echo "Using free tier"
        fi

    - name: Terraform Plan for Cost Analysis
      id: terraform-plan
      run: |
        cd infra
        terraform init
        terraform plan -out=tfplan
        
        # Only use Infracost for accurate cost estimation
        if command -v infracost &> /dev/null; then
          echo "Using Infracost for accurate cost estimation..."
          mkdir -p ../cost-analysis
          
          # Try to get Infracost breakdown with usage file
          if infracost breakdown --path tfplan --usage-file infracost-usage.yml --format json > ../cost-analysis/infracost.json 2>&1; then
            ESTIMATED_COST=$(jq -r '.totalMonthlyCost' ../cost-analysis/infracost.json 2>/dev/null || echo "unavailable")
            
            if [ "$ESTIMATED_COST" != "null" ] && [ "$ESTIMATED_COST" != "unavailable" ] && [ "$ESTIMATED_COST" != "0" ]; then
              echo "✅ Infracost estimation successful with usage data: \$$ESTIMATED_COST/month"
              echo "estimated-cost=$ESTIMATED_COST" >> $GITHUB_OUTPUT
              echo "cost-available=true" >> $GITHUB_OUTPUT
              
              # Show cost breakdown for transparency
              echo "📊 Cost breakdown by service:"
              jq -r '.projects[0].breakdown.resources[] | "\(.name): $\(.monthlyCost // 0)"' ../cost-analysis/infracost.json | head -10
            else
              echo "⚠️  Infracost returned invalid cost data"
              echo "estimated-cost=unavailable" >> $GITHUB_OUTPUT
              echo "cost-available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Infracost breakdown failed"
            cat ../cost-analysis/infracost.json 2>/dev/null || echo "No error output available"
            echo "estimated-cost=unavailable" >> $GITHUB_OUTPUT
            echo "cost-available=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "❌ Infracost not available"
          echo "estimated-cost=unavailable" >> $GITHUB_OUTPUT
          echo "cost-available=false" >> $GITHUB_OUTPUT
        fi

    - name: Cost Gate Decision
      id: cost-gate
      run: |
        mkdir -p cost-analysis
        ESTIMATED_COST="${{ steps.terraform-plan.outputs.estimated-cost }}"
        COST_AVAILABLE="${{ steps.terraform-plan.outputs.cost-available }}"
        
        # Simplified cost gate - if we can't get costs, assume it's reasonable for development
        if [ "$COST_AVAILABLE" == "false" ] || [ "$ESTIMATED_COST" == "unavailable" ]; then
          echo "⚠️  Cost estimation unavailable, proceeding with deployment"
          echo "approved=true" >> $GITHUB_OUTPUT
          echo "estimated-cost=unknown" >> $GITHUB_OUTPUT
        else
          echo "📊 Cost analysis successful: \$$ESTIMATED_COST/month"
          
          # Convert to integer for comparison (remove decimal if present)
          COST_INT=$(echo "$ESTIMATED_COST" | cut -d'.' -f1)
          
          # Simplified cost thresholds - fail only if very expensive
          if [ "$COST_INT" -gt 25 ]; then
            echo "❌ COST GATE FAILED: Estimated cost \$$ESTIMATED_COST exceeds \$25/month limit"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "✅ COST GATE PASSED: Estimated cost \$$ESTIMATED_COST within budget"
            echo "approved=true" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Upload Cost Analysis Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cost-analysis-results
        path: |
          cost-analysis/
          infra/infracost-usage.yml
        retention-days: 30

  # Stage 3: Deploy to Staging
  deploy-to-staging:
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Staging
    needs: [security-validation, cost-analysis]
    if: |
      needs.security-validation.outputs.security-approved == 'true' &&
      needs.cost-analysis.outputs.cost-approved == 'true' &&
      github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy Infrastructure
      run: |
        cd infra
        terraform init
        terraform apply -auto-approve
        
        # Get outputs for function deployment
        FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
        RESOURCE_GROUP=$(terraform output -raw resource_group_name)
        
        echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME" >> $GITHUB_ENV
        echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Deploy Function App
      run: |
        cd functions
        npm ci --production
        zip -r ../function-app.zip .
        az functionapp deployment source config-zip \
          --resource-group $RESOURCE_GROUP \
          --name $FUNCTION_APP_NAME \
          --src ../function-app.zip

  # Stage 4: Integration Tests
  run-integration-tests:
    runs-on: ubuntu-latest
    name: Run End-to-End Integration Tests
    needs: deploy-staging
    if: needs.deploy-staging.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Run Integration Tests
      run: |
        # Install test dependencies
        pip install pytest requests azure-identity azure-keyvault-secrets
        
        # Get function app URL
        cd infra
        terraform init
        FUNCTION_URL=$(terraform output -raw function_app_url)
        cd ..
        
        # Run tests
        export FUNCTION_URL=$FUNCTION_URL
        python -m pytest tests/integration/ -v

  # Stage 5: Deploy to Production (main branch only)
  deploy-to-production:
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Production
    needs: [security-validation, cost-analysis, integration-tests]
    if: |
      always() && 
      needs.integration-tests.result == 'success' &&
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2

    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ vars.AZURE_CLIENT_ID }}
        tenant-id: ${{ vars.AZURE_TENANT_ID }}
        subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy to Production
      run: |
        # Similar deployment steps but to production environment
        echo "🚀 Deploying to production..."
        # Production deployment logic here

  # Stage 6: Notification
  deployment-notification:
    runs-on: ubuntu-latest
    name: Deployment Status Notification
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: Notify Deployment Status
      run: |
        if [ "${{ needs.deploy-staging.result }}" == "success" ]; then
          echo "✅ Staging deployment completed successfully"
        fi
        if [ "${{ needs.deploy-production.result }}" == "success" ]; then
          echo "✅ Production deployment completed successfully"
        fi
        if [ "${{ needs.deploy-staging.result }}" == "failure" ] || [ "${{ needs.deploy-production.result }}" == "failure" ]; then
          echo "❌ Deployment failed - check logs for details"
        fi
