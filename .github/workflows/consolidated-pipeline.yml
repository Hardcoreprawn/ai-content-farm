name: Consolidated CI/CD Pipeline

on:
  push:
    branches: [ develop, main ]
    paths:
      - 'functions/**'
      - 'infra/**'
      - 'tests/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'functions/**'
      - 'infra/**'
      - 'tests/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_security:
        description: 'Skip security checks (use with caution)'
        required: false
        default: false
        type: boolean
      skip_cost:
        description: 'Skip cost checks (when Infracost unavailable)'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip integration tests (for urgent deployments)'
        required: false
        default: false
        type: boolean

# OIDC permissions for Azure authentication
permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

env:
  AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}

jobs:
  # Detect changes for conditional execution
  changes:
    runs-on: ubuntu-latest
    outputs:
      infrastructure: ${{ steps.changes.outputs.infrastructure }}
      functions: ${{ steps.changes.outputs.functions }}
      tests: ${{ steps.changes.outputs.tests }}
      docs: ${{ steps.changes.outputs.docs }}
      workflows: ${{ steps.changes.outputs.workflows }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            infrastructure:
              - 'infra/**'
            functions:
              - 'functions/**'
            tests:
              - 'tests/**'
            docs:
              - 'docs/**'
              - '*.md'
            workflows:
              - '.github/workflows/**'
              - '.yamllint.yaml'

  # Workflow Validation (for workflow changes)
  workflow-lint:
    if: ${{ needs.changes.outputs.workflows == 'true' }}
    runs-on: ubuntu-latest
    name: YAML and Actions Lint
    needs: changes
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
          cache: 'pip'

      - name: Install yamllint
        run: pip install yamllint

      - name: Run yamllint
        run: yamllint -f colored .

      - name: Run actionlint
        uses: docker://rhysd/actionlint:latest
        with:
          args: -color

  # Stage 1: Parallel Validation Gates
  security-gate:
    # Skip security scans for docs-only changes
    if: >
      ${{ (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
          (github.event.inputs.skip_security != 'true') &&
          needs.changes.outputs.docs != 'true' }}
    runs-on: ubuntu-latest
    name: Security and Compliance Validation
    needs: changes
    outputs:
      security-approved: ${{ steps.security-gate.outputs.approved }}
      critical-findings: ${{ steps.security-gate.outputs.critical-findings }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Cache Security Tools
        id: cache-security-tools
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/bin/tfsec
            /usr/local/bin/terrascan
            /usr/local/bin/syft
          key: security-tools-${{ runner.os }}-v2

      - name: Install Security Tools
        if: steps.cache-security-tools.outputs.cache-hit != 'true'
        run: |
          # Install tools in parallel for speed
          {
            pip3 install checkov &
            PIP_PID=$!

            # Install tfsec
            wget -O tfsec https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64 \
              && chmod +x tfsec && sudo mv tfsec /usr/local/bin &
            TFSEC_PID=$!

            # Install terrascan
            LATEST_URL=$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E "https://.*Linux_x86_64.tar.gz" | head -1)
            curl -L "$LATEST_URL" > terrascan.tar.gz \
              && tar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz \
              && sudo mv terrascan /usr/local/bin &
            TERRASCAN_PID=$!

            # Install syft
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin &
            SYFT_PID=$!

            # Wait for all installations
            wait $PIP_PID $TFSEC_PID $TERRASCAN_PID $SYFT_PID
          }

      - name: Ensure tools are available (from cache or fresh install)
        run: |
          pip3 install checkov

      - name: Run Security Scans (Parallel)
        id: security-scans
        continue-on-error: true
        run: |
          echo "Running comprehensive security scans in parallel..."
          mkdir -p security-results

          # Run scans in parallel for faster execution
          {
            # Checkov - infrastructure
            checkov -d infra --quiet --compact --output json --output-file-path security-results/checkov.json &
            CHECKOV_INFRA_PID=$!

            # Checkov - functions
            checkov -d functions --quiet --compact --output json --output-file-path security-results/checkov-functions.json &
            CHECKOV_FUNC_PID=$!

            # TFSec
            (cd infra/application && tfsec . --format json --out ../../security-results/tfsec.json --soft-fail) &
            TFSEC_PID=$!

            # Terrascan
            (cd infra/application && terrascan scan -i terraform --output json > ../../security-results/terrascan.json) &
            TERRASCAN_PID=$!

            # SBOM generation
            syft functions -o json=security-results/sbom.json &
            SBOM_PID=$!

            # Wait for all scans to complete
            wait $CHECKOV_INFRA_PID $CHECKOV_FUNC_PID $TFSEC_PID $TERRASCAN_PID $SBOM_PID
          }

          echo "All security scans completed"

      - name: Security Gate Decision
        id: security-gate
        run: |
          mkdir -p security-results

          # Analyze security scan results
          CRITICAL_COUNT=0
          HIGH_COUNT=0

          # Check Checkov results for critical/high findings
          if [ -f security-results/checkov.json ]; then
            CRITICAL_COUNT=$(
              jq \
                '.results.failed_checks
                 | map(select(.severity == "CRITICAL"))
                 | length' \
                security-results/checkov.json 2>/dev/null \
              || echo 0
            )
            HIGH_COUNT=$(
              jq \
                '.results.failed_checks
                 | map(select(.severity == "HIGH"))
                 | length' \
                security-results/checkov.json 2>/dev/null \
              || echo 0
            )
          fi

          echo "Critical findings: $CRITICAL_COUNT"
          echo "High findings: $HIGH_COUNT"
          echo "critical-findings=$CRITICAL_COUNT" >> "$GITHUB_OUTPUT"

          # Simplified security gate logic - pass or fail
          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "❌ SECURITY GATE FAILED: $CRITICAL_COUNT critical security findings detected"
            echo "approved=false" >> "$GITHUB_OUTPUT"
            exit 1
          elif [ "$HIGH_COUNT" -gt 10 ]; then
            echo "❌ SECURITY GATE FAILED: $HIGH_COUNT high-severity findings exceed limit (>10)"
            echo "approved=false" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "✅ SECURITY GATE PASSED: No critical findings, $HIGH_COUNT high findings"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload Security Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: security-results/
          retention-days: 30

  # Stage 2: Cost Impact Analysis (Parallel with Security, Infrastructure changes only)
  cost-gate:
    if: >
      ${{ (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
          (github.event.inputs.skip_cost != 'true') &&
          needs.changes.outputs.infrastructure == 'true' }}
    runs-on: ubuntu-latest
    name: Cost Impact and Budget Approval
    needs: changes
    outputs:
      cost-approved: ${{ steps.cost-gate.outputs.approved }}
      estimated-cost: ${{ steps.cost-gate.outputs.estimated-cost }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Cache Terraform Providers
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/application/.terraform
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('infra/application/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-providers-${{ runner.os }}-

      - name: Install Infracost (Cached)
        uses: infracost/actions/setup@v3
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY || 'ico-free-tier-key' }}

      - name: Fast Terraform Plan for Cost Analysis
        id: terraform-plan
        run: |
          cd infra/application

          # Configure backend for remote state with caching
          ENV_INPUT="${{ github.event.inputs.environment }}"
          if [ -z "$ENV_INPUT" ]; then ENV_INPUT="staging"; fi

          # Use cached terraform if available
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          mkdir -p $TF_PLUGIN_CACHE_DIR

          if [ "$ENV_INPUT" = "production" ]; then
            terraform init -backend-config=backend-production.hcl
          else
            terraform init -backend-config=backend-staging.hcl
          fi

          # Create terraform plan optimized for cost analysis
          echo "🔧 Creating optimized Terraform plan for cost analysis..."
          if terraform plan -out=tfplan -var="environment=${{ github.event.inputs.environment || 'staging' }}" -refresh=false 2>&1 | tee plan.log; then
            echo "Terraform plan successful"
            PLAN_SUCCESS=true
          else
            echo "Terraform plan had issues, checking if they're permission-related..."
            PLAN_SUCCESS=false

            # Check if errors are related to Key Vault permissions (expected on first deployment)
            if grep -q "does not have secrets get permission\|Authorization_RequestDenied" plan.log; then
              echo "Detected expected permission errors for first deployment - proceeding"
              PLAN_SUCCESS=true
            fi
          fi

          if [ "$PLAN_SUCCESS" = "false" ]; then
            echo "Terraform plan failed with non-permission errors"
            cat plan.log
            exit 1
          fi

          # Fast Infracost analysis
          echo "Running fast cost analysis..."
          mkdir -p ../cost-analysis

          if infracost breakdown --path tfplan --format json > ../cost-analysis/infracost.json 2>&1; then
            ESTIMATED_COST=$(jq -r '.totalMonthlyCost' ../cost-analysis/infracost.json 2>/dev/null || echo "unavailable")
            echo "estimated-cost=$ESTIMATED_COST" >> "$GITHUB_OUTPUT"
            echo "cost-available=true" >> "$GITHUB_OUTPUT"
          else
            echo "estimated-cost=unavailable" >> "$GITHUB_OUTPUT"
            echo "cost-available=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Cost Gate Decision
        id: cost-gate
        run: |
          ESTIMATED_COST="${{ steps.terraform-plan.outputs.estimated-cost }}"
          COST_AVAILABLE="${{ steps.terraform-plan.outputs.cost-available }}"

          # Fast cost gate decision
          if [ "$COST_AVAILABLE" = "false" ] || [ "$ESTIMATED_COST" = "unavailable" ]; then
            echo "⚠️  Cost estimation unavailable, proceeding with deployment"
            echo "approved=true" >> "$GITHUB_OUTPUT"
            echo "estimated-cost=unknown" >> "$GITHUB_OUTPUT"
          else
            echo "📊 Cost analysis: \$$ESTIMATED_COST/month"
            COST_INT=$(echo "$ESTIMATED_COST" | cut -d'.' -f1)

            if [ "$COST_INT" -gt 25 ]; then
              echo "❌ COST GATE FAILED: \$$ESTIMATED_COST exceeds \$25/month"
              echo "approved=false" >> "$GITHUB_OUTPUT"
              exit 1
            else
              echo "✅ COST GATE PASSED: \$$ESTIMATED_COST within budget"
              echo "approved=true" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Upload Cost Analysis Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cost-analysis-results
          path: cost-analysis/
          retention-days: 7

  # Stage 3: Deploy to Staging (Wait for relevant gates)
  deploy-to-staging:
    if: >
      ${{ (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
          (needs.changes.outputs.infrastructure == 'true' || needs.changes.outputs.functions == 'true') }}
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Staging
    needs: [changes, security-gate, cost-gate]
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Restore Terraform Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/application/.terraform
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('infra/application/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-providers-${{ runner.os }}-

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Infrastructure
        run: |
          cd infra/application

          # Use cached providers for faster init
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          mkdir -p $TF_PLUGIN_CACHE_DIR

          # Fast terraform init (providers cached)
          terraform init -backend-config=backend-staging.hcl

          terraform apply -auto-approve -var-file="staging.tfvars"

          # Get outputs for function deployment
          FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
          RESOURCE_GROUP=$(terraform output -raw resource_group_name)
          KEY_VAULT_NAME=$(terraform output -raw key_vault_name)

          {
            echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME"
            echo "RESOURCE_GROUP=$RESOURCE_GROUP"
            echo "KEY_VAULT_NAME=$KEY_VAULT_NAME"
          } >> "$GITHUB_ENV"

      - name: Deploy Python Function App
        run: |
          cd functions

          # Create deployment package for Python Azure Functions
          # Azure Functions expects the function files directly, not in a venv
          zip -r ../function-app.zip . -x "*.pyc" "*/__pycache__/*" ".python_packages/*"

          # Deploy using Azure CLI (works reliably for Python functions)
          echo "Deploying function app package..."
          az functionapp deployment source config-zip \
            --resource-group "$RESOURCE_GROUP" \
            --name "$FUNCTION_APP_NAME" \
            --src ../function-app.zip

          echo "Function app deployment completed"
          echo "Note: Functions may need time to register after deployment (cold start)"

      - name: Wire SummaryWomble key to app setting
        run: |
          # Use IaC-managed secret from Key Vault as the SummaryWomble function key
          echo "Retrieving SummaryWomble function key from Key Vault ($KEY_VAULT_NAME)..."
          SECRET=$(az keyvault secret show \
            --vault-name "$KEY_VAULT_NAME" \
            --name summarywomble-function-key \
            --query value -o tsv)

          if [ -z "$SECRET" ] || [ "$SECRET" = "null" ]; then
            echo "Missing Key Vault secret 'summarywomble-function-key'" && exit 1
          fi

          # Optimized wait for function registration (reduced from 20 attempts)
          echo "Waiting for SummaryWomble to register..."
          for i in {1..10}; do
            if az functionapp function show \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble 1>/dev/null 2>&1; then
              echo "Function 'SummaryWomble' is present"
              break
            fi
            echo "Attempt $i/10: function not found yet; sleeping 8s..."
            sleep 8
          done

          # Fast retry for function key setting (reduced retries)
          echo "Setting SummaryWomble function key"
          for i in {1..3}; do
            if az functionapp function keys set \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble \
              --key-name internal \
              --key-value "$SECRET" 1>/dev/null; then
              echo "Function key set successfully"
              break
            fi
            echo "Key set failed (attempt $i/3). Waiting 5s..."
            sleep 5
          done

          # Restart to ensure settings are applied
          az functionapp restart --name "$FUNCTION_APP_NAME" --resource-group "$RESOURCE_GROUP"

  # Stage 4: Fast Integration Tests (Skip if tests disabled)
  run-integration-tests:
    if: >
      ${{ (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') &&
          (github.event.inputs.skip_tests != 'true') &&
          (needs.changes.outputs.functions == 'true' || needs.changes.outputs.tests == 'true') }}
    runs-on: ubuntu-latest
    name: Run Essential Integration Tests
    needs: [changes, deploy-to-staging]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform (Cached)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Fast Integration Tests
        run: |
          # Install test dependencies quickly
          pip install pytest requests azure-identity azure-keyvault-secrets

          # Get function app URL from terraform outputs (cached providers)
          cd infra/application
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          terraform init -backend-config=backend-staging.hcl

          FUNCTION_URL=$(terraform output -raw function_app_url)
          FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
          cd ../..

          echo "Testing function app: $FUNCTION_APP_NAME"
          echo "Function URL: $FUNCTION_URL"

          # Optimized readiness check (reduced from 30 attempts x 15s = 7.5min to 10 attempts x 10s = 1.7min max)
          echo "Fast readiness check..."
          READY=false
          for i in {1..10}; do
            echo "Attempt $i/10: Checking function app..."

            # Quick health check
            if curl -s --max-time 10 "$FUNCTION_URL" > /dev/null; then
              # Test SummaryWomble endpoint (should return 401, not 404)
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$FUNCTION_URL/api/SummaryWomble" || echo "000")

              if [ "$STATUS" = "401" ] || [ "$STATUS" = "400" ]; then
                echo "✅ Function app ready (SummaryWomble: $STATUS)"
                READY=true
                break
              elif [ "$STATUS" = "404" ]; then
                echo "⏳ SummaryWomble not registered yet ($STATUS)"
              else
                echo "⚠️  Unexpected status: $STATUS"
              fi
            else
              echo "⏳ Function app not responding"
            fi

            sleep 10
          done

          if [ "$READY" = "false" ]; then
            echo "⚠️  Function app not ready within timeout, running tests anyway"
          fi

          # Run fast essential tests only
          export FUNCTION_URL=$FUNCTION_URL
          export FUNCTION_APP_NAME=$FUNCTION_APP_NAME
          python -m pytest tests/integration/test_pipeline.py::TestContentPipeline::test_summary_womble_endpoint \
            -v --tb=short --timeout=60

  # Stage 5: Deploy to Production (main branch only, after all validations)
  deploy-to-production:
    if: >
      ${{ github.ref == 'refs/heads/main' &&
          ((github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')) &&
          (needs.changes.outputs.infrastructure == 'true' || needs.changes.outputs.functions == 'true') }}
    runs-on: ubuntu-latest
    name: Deploy Infrastructure and Functions to Production
    needs: [changes, security-gate, cost-gate, run-integration-tests]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Restore Terraform Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/application/.terraform
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('infra/application/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-providers-${{ runner.os }}-

      - name: Deploy to Production
        run: |
          cd infra/application

          # Use cached providers for faster init
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          mkdir -p $TF_PLUGIN_CACHE_DIR

          # Configure backend for remote state
          terraform init -backend-config=backend-production.hcl

           terraform apply -auto-approve -var-file="production.tfvars"

          # Get outputs for function deployment
          FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
          RESOURCE_GROUP=$(terraform output -raw resource_group_name)

          {
            echo "FUNCTION_APP_NAME=$FUNCTION_APP_NAME"
            echo "RESOURCE_GROUP=$RESOURCE_GROUP"
          } >> "$GITHUB_ENV"

      - name: Deploy Python Function App to Production
        run: |
          cd functions

          # Create deployment package for Python Azure Functions
          zip -r ../function-app-prod.zip . -x "*.pyc" "*/__pycache__/*" ".python_packages/*"

          # Deploy using Azure CLI
          az functionapp deployment source config-zip \
            --resource-group "$RESOURCE_GROUP" \
            --name "$FUNCTION_APP_NAME" \
            --src ../function-app-prod.zip

      - name: Wire SummaryWomble key to app setting (production)
        run: |
          echo "Retrieving SummaryWomble function key from Key Vault (production)..."
          # Get KEY_VAULT_NAME from terraform output (cached)
          cd infra/application
          export TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache
          terraform init -backend-config=backend-production.hcl
          KEY_VAULT_NAME=$(terraform output -raw key_vault_name)
          cd ../..

          SECRET=$(az keyvault secret show \
            --vault-name "$KEY_VAULT_NAME" \
            --name summarywomble-function-key \
            --query value -o tsv)

          if [ -z "$SECRET" ] || [ "$SECRET" = "null" ]; then
            echo "Missing Key Vault secret 'summarywomble-function-key' (production)" && exit 1
          fi

          # Optimized wait (reduced from 20 attempts)
          echo "Waiting for SummaryWomble to register (production)..."
          for i in {1..10}; do
            if az functionapp function show \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble 1>/dev/null 2>&1; then
              echo "Function 'SummaryWomble' is present"
              break
            fi
            echo "Attempt $i/10: function not found yet; sleeping 8s..."
            sleep 8
          done

          # Fast retry (reduced retries)
          echo "Setting SummaryWomble function key (production)"
          for i in {1..3}; do
            if az functionapp function keys set \
              --name "$FUNCTION_APP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --function-name SummaryWomble \
              --key-name internal \
              --key-value "$SECRET" 1>/dev/null; then
              echo "Function key set successfully"
              break
            fi
            echo "Key set failed (attempt $i/3). Waiting 5s..."
            sleep 5
          done

          az functionapp restart --name "$FUNCTION_APP_NAME" --resource-group "$RESOURCE_GROUP"

  # Stage 6: Deployment Summary
  deployment-notification:
    runs-on: ubuntu-latest
    name: Pipeline Summary
    needs: [changes, deploy-to-staging, deploy-to-production]
    if: always()

    steps:
      - name: Pipeline Summary
        run: |
          echo "## 🚀 Pipeline Execution Summary"
          echo "**Changed Components:**"
          echo "- Infrastructure: ${{ needs.changes.outputs.infrastructure }}"
          echo "- Functions: ${{ needs.changes.outputs.functions }}"
          echo "- Tests: ${{ needs.changes.outputs.tests }}"
          echo "- Docs: ${{ needs.changes.outputs.docs }}"
          echo ""

          if [ "${{ needs.deploy-to-staging.result }}" == "success" ]; then
            echo "✅ Staging deployment completed successfully"
          elif [ "${{ needs.deploy-to-staging.result }}" == "skipped" ]; then
            echo "⏭️ Staging deployment skipped (no infrastructure/function changes)"
          fi

          if [ "${{ needs.deploy-to-production.result }}" == "success" ]; then
            echo "✅ Production deployment completed successfully"
          elif [ "${{ needs.deploy-to-production.result }}" == "skipped" ]; then
            echo "⏭️ Production deployment skipped (not main branch or no changes)"
          fi

          if [ "${{ needs.deploy-to-staging.result }}" == "failure" ] || [ "${{ needs.deploy-to-production.result }}" == "failure" ]; then
            echo "❌ Deployment failed - check logs for details"
            exit 1
          fi
