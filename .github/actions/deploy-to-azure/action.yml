name: 'Deploy to Azure Container Apps'
description: 'Deploys service containers to Azure Container Apps using multi-tier strategy'
inputs:
  client-id:
    description: 'Azure service principal client ID'
    required: true
  tenant-id:
    description: 'Azure tenant ID'
    required: true
  subscription-id:
    description: 'Azure subscription ID'
    required: true
  resource-group:
    description: 'Azure resource group name'
    required: true
    default: 'ai-content-farm-core-rg'
  acr-name:
    description: 'Azure Container Registry name'
    required: true
    default: 'aicontentfarm76ko2hacr'
  environment:
    description: 'Environment to deploy to (staging/production)'
    required: true
    default: 'production'
  containers:
    description: 'Comma-separated list of containers to deploy (default: all)'
    required: false
    default: 'all'
  terraform-storage-account:
    description: 'Terraform state storage account name'
    required: false
    default: 'aicontentstagingstv33ppo'
outputs:
  deployment-url:
    description: 'URL of the deployed application'
    value: ${{ steps.deploy.outputs.url }}
  deployed-containers:
    description: 'List of containers that were deployed'
    value: ${{ steps.deploy.outputs.containers }}

runs:
  using: 'composite'
  steps:
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ inputs.client-id }}
        tenant-id: ${{ inputs.tenant-id }}
        subscription-id: ${{ inputs.subscription-id }}

    - name: Deploy Infrastructure
      shell: bash
      env:
        ENVIRONMENT: ${{ inputs.environment }}
        STORAGE_ACCOUNT: ${{ inputs.terraform-storage-account }}
      run: |
        echo "[PACKAGE] Deploying infrastructure with Terraform..."
        cd infra

        # Initialize Terraform with environment-specific state file
        echo "[CONFIG] Using state file: terraform-${ENVIRONMENT}.tfstate"
        docker run --rm \
          -v "${PWD}":/workspace \
          -w /workspace \
          hashicorp/terraform:latest \
          init -reconfigure \
          -backend-config="key=terraform-${ENVIRONMENT}.tfstate" \
          -backend-config="storage_account_name=${STORAGE_ACCOUNT}"

        # Plan and apply (no workspace needed with separate state files)
        docker run --rm \
          -v "${PWD}":/workspace \
          -w /workspace \
          hashicorp/terraform:latest \
          plan -var-file="${ENVIRONMENT}.tfvars" -out=tfplan

        docker run --rm \
          -v "${PWD}":/workspace \
          -w /workspace \
          hashicorp/terraform:latest \
          apply -auto-approve tfplan

        echo "[PASS] Infrastructure deployed"

    - name: Build and Push Base Images
      shell: bash
      env:
        ACR_NAME: ${{ inputs.acr-name }}
        RESOURCE_GROUP: ${{ inputs.resource-group }}
      run: |
        echo "[BUILD] Building and pushing multi-tier base images to ACR..."

        # Get ACR login server
        ACR_LOGIN_SERVER=$(az acr show --name "$ACR_NAME" --resource-group "$RESOURCE_GROUP" --query loginServer -o tsv)
        echo "[REPORT] ACR Login Server: $ACR_LOGIN_SERVER"

        # Login to ACR
        az acr login --name "$ACR_NAME"

        # Build and push base images
        base_images=("foundation" "common-deps" "web-services" "data-processing" "scheduler")

        for tier in "${base_images[@]}"; do
          echo "Building and pushing $tier base image..."

          # Build base image
          docker build -f containers/base/Dockerfile.multitier \
            -t ai-content-farm-base:$tier \
            --target $tier .

          # Tag for ACR
          docker tag ai-content-farm-base:$tier $ACR_LOGIN_SERVER/ai-content-farm-base:$tier

          # Push to ACR
          docker push $ACR_LOGIN_SERVER/ai-content-farm-base:$tier

          echo "[PASS] $tier base image pushed to ACR"
        done

    - name: Build and Push Service Containers
      shell: bash
      env:
        ACR_NAME: ${{ inputs.acr-name }}
        RESOURCE_GROUP: ${{ inputs.resource-group }}
        CONTAINERS: ${{ inputs.containers }}
      run: |
        echo "[BUILD] Building and pushing service containers..."

        ACR_LOGIN_SERVER=$(az acr show --name "$ACR_NAME" --resource-group "$RESOURCE_GROUP" --query loginServer -o tsv)

        # Determine which containers to deploy
        if [ "$CONTAINERS" = "all" ]; then
          CONTAINERS=("content-generator" "content-enricher" "content-processor" "content-ranker" "markdown-generator" "site-generator" "content-collector" "collector-scheduler")
        else
          IFS=',' read -ra CONTAINERS <<< "$CONTAINERS"
        fi

        for container in "${CONTAINERS[@]}"; do
          echo "Building and pushing $container..."

          # Build from repo root with correct context
          docker build -f containers/$container/Dockerfile -t $container:latest .

          # Tag for ACR
          docker tag $container:latest $ACR_LOGIN_SERVER/$container:latest

          # Push to ACR
          docker push $ACR_LOGIN_SERVER/$container:latest

          echo "[PASS] $container pushed to ACR"
        done

    - name: Update Container Apps
      id: deploy
      shell: bash
      env:
        ACR_NAME: ${{ inputs.acr-name }}
        RESOURCE_GROUP: ${{ inputs.resource-group }}
      run: |
        echo "[PROCESS] Updating Container Apps..."

        ACR_LOGIN_SERVER=$(az acr show --name "$ACR_NAME" --resource-group "$RESOURCE_GROUP" --query loginServer -o tsv)
        deployed_containers=""

        # Get resource prefix from environment or use default
        RESOURCE_PREFIX=${RESOURCE_PREFIX:-"ai-content-dev"}

        # Deploy customer-facing services first, then content pipeline
        declare -A container_apps=(
          ["site-generator"]="${RESOURCE_PREFIX}-site-gen"
          ["content-generator"]="${RESOURCE_PREFIX}-content-gen"
          ["content-collector"]="${RESOURCE_PREFIX}-collector"
          ["content-ranker"]="${RESOURCE_PREFIX}-ranker"
        )

        for container in "${!container_apps[@]}"; do
          app_name="${container_apps[$container]}"
          echo "Updating $container -> $app_name..."

          # Check if container app exists
          if az containerapp show --name "$app_name" --resource-group "$RESOURCE_GROUP" >/dev/null 2>&1; then
            az containerapp update \
              --name "$app_name" \
              --resource-group "$RESOURCE_GROUP" \
              --image $ACR_LOGIN_SERVER/$container:latest

            echo "[PASS] $container container app updated"

            if [ -z "$deployed_containers" ]; then
              deployed_containers="$container"
            else
              deployed_containers="$deployed_containers,$container"
            fi
          else
            echo "[WARNING] Container app $app_name does not exist - skipping $container"
          fi
        done

        # Get deployment URL from site-generator (customer-facing)
        DEPLOYMENT_URL=$(az containerapp show \
          --name "${RESOURCE_PREFIX}-site-gen" \
          --resource-group "$RESOURCE_GROUP" \
          --query "properties.configuration.ingress.fqdn" \
          -o tsv 2>/dev/null)

        if [ -n "$DEPLOYMENT_URL" ]; then
          echo "[SUCCESS] Website URL: https://$DEPLOYMENT_URL"
          echo "url=https://$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
        else
          echo "[WARNING] Could not retrieve deployment URL"
          echo "url=" >> $GITHUB_OUTPUT
        fi
        echo "containers=$deployed_containers" >> $GITHUB_OUTPUT
