name: 'Build Single Container (Optimized)'
description: 'Builds a single service container with optimized caching for speed'
inputs:
  container-name:
    description: 'Name of the container to build'
    required: true
  registry:
    description: 'Container registry to tag images for (optional)'
    required: false
    default: ''
  enable-cache:
    description: 'Enable Docker layer caching'
    required: false
    default: 'true'
  dependency-results-path:
    description: 'Path to dependency analysis results from previous job'
    required: false
    default: ''
outputs:
  build-result:
    description: 'Build result: success or failure'
    value: ${{ steps.build.outputs.result }}
  image-tag:
    description: 'Full image tag that was built'
    value: ${{ steps.build.outputs.image-tag }}

runs:
  using: 'composite'
  steps:
    - name: Build Container (Optimized)
      id: build
      shell: bash
      env:
        CONTAINER_NAME: ${{ inputs.container-name }}
        ENABLE_CACHE: ${{ inputs.enable-cache }}
        REGISTRY: ${{ inputs.registry }}
      run: |
        echo "[BUILD] Building container: $CONTAINER_NAME (optimized for speed)"

        container_dir="containers/$CONTAINER_NAME"
        dockerfile_path="$container_dir/Dockerfile"

        # Verify files exist
        if [ ! -d "$container_dir" ]; then
          echo "[ERROR] Container directory not found: $container_dir"
          echo "result=failure" >> $GITHUB_OUTPUT
          exit 1
        fi

        if [ ! -f "$dockerfile_path" ]; then
          echo "[ERROR] Dockerfile not found: $dockerfile_path"
          echo "result=failure" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Check for existing dependency analysis results
        dependency_results_path="${{ inputs.dependency-results-path }}"
        if [ -n "$dependency_results_path" ] && [ -d "$dependency_results_path" ]; then
          safety_result_file="$dependency_results_path/safety-${CONTAINER_NAME}.json"
          if [ -f "$safety_result_file" ]; then
            echo "[DEPENDENCY] Using cached dependency analysis for $CONTAINER_NAME"

            # Check if vulnerabilities were found
            if [ -s "$safety_result_file" ] && grep -q '"vulnerabilities"' "$safety_result_file" 2>/dev/null; then
              vuln_count=$(jq -r '.vulnerabilities | length' "$safety_result_file" 2>/dev/null || echo "unknown")
              if [ "$vuln_count" != "0" ] && [ "$vuln_count" != "null" ]; then
                echo "[WARN] $vuln_count vulnerabilities found in dependencies for $CONTAINER_NAME"
                cat "$dependency_results_path/safety-${CONTAINER_NAME}.txt" || true
              else
                echo "[PASS] No dependency vulnerabilities found for $CONTAINER_NAME"
              fi
            else
              echo "[PASS] No dependency vulnerabilities found for $CONTAINER_NAME"
            fi
          else
            echo "[INFO] No cached dependency analysis found for $CONTAINER_NAME, proceeding with build"
          fi
        else
          echo "[INFO] No dependency results path provided, proceeding with build"
        fi

        # Build image with optimized caching
        image_tag="$CONTAINER_NAME:latest"
        echo "[BUILD] Building image: $image_tag"

        # Configure aggressive caching for speed
        build_args="--cache-from=type=gha --cache-to=type=gha,mode=max"

        if [ "$ENABLE_CACHE" = "false" ]; then
          build_args="--no-cache"
        fi

        echo "[INFO] Using Docker BuildKit with caching: $build_args"

        if docker build $build_args -f "$dockerfile_path" -t "$image_tag" .; then
          echo "[PASS] $CONTAINER_NAME built successfully"

          # Tag for registry if provided
          if [ -n "$REGISTRY" ]; then
            registry_tag="$REGISTRY/$image_tag"
            docker tag "$image_tag" "$registry_tag"
            echo "[INFO] Tagged for registry: $registry_tag"
            echo "image-tag=$registry_tag" >> $GITHUB_OUTPUT
          else
            echo "image-tag=$image_tag" >> $GITHUB_OUTPUT
          fi

          # Clean up local image (keep if registry provided for potential push)
          if [ -z "$REGISTRY" ]; then
            docker rmi "$image_tag" || true
            echo "[CLEANUP] Removed local image to save space"
          fi

          echo "result=success" >> $GITHUB_OUTPUT
        else
          echo "[FAIL] $CONTAINER_NAME build failed"
          echo "result=failure" >> $GITHUB_OUTPUT
          exit 1
        fi
